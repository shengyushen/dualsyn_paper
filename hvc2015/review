----------------------- REVIEW 1 --------------------- PAPER: 10 TITLE:
Complementary Synthesis for Encoders with Pipeline and Flow Control Mechanism
AUTHORS: Ying Qin, Shengyu Shen, Huadong Dai, Qingbo Wu and Yan Jia

OVERALL EVALUATION: 0 (borderline paper) REVIEWER'S CONFIDENCE: 3 (medium)

----------- REVIEW ----------- In this paper, the authors proposes a
complementary synthesis algorithm that can handle encoders with pipeline stages
and flow control mechanism (unlike previous methods that can generate an
encoder's corresponding decoder when pipeline stages are not present).

This is a grammatically and structurally very well written paper. My only
question relates to Table 1, experimental results and the column "decoder
generated by [15]." Is this an apples-to-apples comparison?  I thought that
[15] could not handle pipeline stages?  The text is not clear one why this was
including in the experimental results.  Perhaps some clarification is needed
here.


----------------------- REVIEW 2 --------------------- PAPER: 10 TITLE:
Complementary Synthesis for Encoders with Pipeline and Flow Control Mechanism
AUTHORS: Ying Qin, Shengyu Shen, Huadong Dai, Qingbo Wu and Yan Jia

OVERALL EVALUATION: 0 (borderline paper) REVIEWER'S CONFIDENCE: 3 (medium)

----------- REVIEW ----------- Paper summary:

The paper studies the problem of automatically synthesizing decoders for
encoders with flow control mechanism and pipeline. Flow control ensures that a
faster transmitter respects the speed of a slower receiver by inserting idle
symbols in the transmission.  Pipelining allows the encoder to run in higher
frequency by having multiple stages.  For many flow control mechanisms the
input of the encoder cannot be determined by observing a bounded sequence of
its outputs. In the case of encoders with pipelines the decoder should also
include pipeline stages in order not to be much slower than the encoder. This
work addresses these two challenges.  Flow control is handled using an existing
algorithm. Here, this algorithm is extended with inference of the pipeline
stages. The functions implementing the resulting decoder that recovers the
encoder's pipeline register values and the encoder's input are computed using
Craig interpolation.  Experimental results comparing the proposed algorithm
with an algorithm that generates decoders without pipelines on 3 benchmarks
demonstrate that pipelined decoders have smaller delay. Two other benchmarks
(the largest ones) are considered in which the encoder does not have pipeline
stages.


===================================================

Evaluation and comments:

The paper is not entirely self-contained and some parts are written in a way
difficult to follow.  For example, no precise definition of the flow control
predicate valid(f) is given. Section 2.4 describes a method for computing this
predicate by iterative under and over approximations.  The algorithm's
description provides insufficient explanation of the intuition and the reader
is referred to [13] for proofs of its termination and correctness.
Essentially, a large part of the paper, namely the whole Section 2, is devoted
to describing the decoder synthesis algorithm from [13], on which the current
work builds upon.

The extension to handling pipelined encoders seems rather straightforward and
is not presented very well.  Section 4.1. describes how to minimize the length
of the output sequence, without motivation.  It also introduces some additional
requirements, without explaining why they are fulfilled, except for stating
that they hold for the benchmarks considered in the experiments section.

Section 4.2 describes how inferring pipeline stages can be reduced to
satisfiability checking by by essentially substituting the respective variables
for the stages for the original variables.  It provides no explanation or
formal justification of the shown reductions. 

Similarly, Section 5 describes how to compute the boolean functions for the
(stages of) the decoder using Craig interpolation. Again, no explanation
regarding correctness is given.

The authors claim that the experimental results demonstrate that their
algorithm can always correctly generate pipelined decoders with flow control
mechanism. Such a generalization, however, cannot be made based on experiments,
but needs formal justification

===================================================

Minor comments and typos:

-- p. 2: Perhaps it should be mentioned that the variables are Boolean.  -- p.
5: "Algorithm 2 characterize" --> "Algorithm 2 characterizes" -- Figure 5 is
the same as Figure 2 with slightly different caption. Perhaps you should remove
it.  -- p. 10: "every registers" --> "every register" -- p. 12: "surprise is,
the" --> "surprising is, that the" -- In the experiments section, why do you
include in Table 1 the benchmarks that have no pipeline?  Furthermore, Sections
6.2 - 6.4 provide details about the synthesized pipelined decoders for 3 of the
benchmarks. I am not sure that presenting these results in detail is of value
to the reader or necessary, given that the reader is not familiar with the
benchmarks themselves.


----------------------- REVIEW 3 --------------------- PAPER: 10 TITLE:
Complementary Synthesis for Encoders with Pipeline and Flow Control Mechanism
AUTHORS: Ying Qin, Shengyu Shen, Huadong Dai, Qingbo Wu and Yan Jia

OVERALL EVALUATION: -2 (reject) REVIEWER'S CONFIDENCE: 2 (low)

----------- REVIEW ----------- This paper is concerned with the automatic
construction of decoders for given encoders. The paper extends existing work to
construct pipelined decoders for pipelined encoders. Such decoders have the
benefit that they can be run at a faster clock speed (closer to that of the
given encoder) than the monolithic decoders that are produced by existing
approaches. 

There were many details in the paper that I did not understand. The abstract
makes it sounds like the treatment of flow control is a contribution, but the
rest of this paper does not bear this out. There is no detailed explanation of
how Equations (1) and (2) correspond to the definition of flow signals. (I had
expected that signals that are NOT  determined by the outputs are flow, the
text before (1) suggests otherwise.) Section 3, I think, contains the
contribution. It proceeds by first identifying the pipeline stages. It is
unclear to me how that is done. Then, it appears to apply the existing approach
to each of the pipeline stages to construct an inverse pipeline stage. The
inverse encoder (the decoder) is then a pipelined circuit consisting of the
inverse stages in the reverse order.

I would have liked to see a discussion of the limitations of the approach.

The experimental results are not entirely convincing. Of five benchmarks tried,
the approach finds pipeline stages in three. The decoders that are constructed
are 13% faster on average, and it is not clear how close their speed is to that
of the encoders or whether the speedup makes a significant difference.

