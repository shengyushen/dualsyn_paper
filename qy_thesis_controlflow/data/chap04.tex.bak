% !Mode:: "Tex:UTF-8"
\chapter{面向流控机制和流水线的对偶综合}
\label{chap:4}

\section{引言}\label{sec_intro}
在通讯和多媒体芯片设计项目中，
一个最困难的工作之一是为不同的协议设计编码器和解码器。
其中编码器负责将输入向量$\vec{i}$ 映射到输出向量$\vec{o}$，
而解码器负责从$\vec{o}$中恢复$\vec{i}$。
对偶综合\cite{ShenICCAD09,ShenTCAD11,ShenTCAD12,LiuICCAD11,LiuTCAD12,TuDAC13}
假设$\vec{i}$ 总能够被 $\vec{o}$唯一决定，
并自动产生相应的解码器。

然而,
许多编码器中采用的留空机制\cite{flowcontrol}
不能满足该要求。
如图\ref{fig_fc}a)所示，
当接收器无法跟上发送器时，
该机制通过发送空闲字符$I$ 以防止快速发送器充爆慢速接收器。
如图\ref{fig_fc}b)所示，
空闲字符$I$
只能唯一决定$\vec{i}$的一部分而非全部，
我们称之为流控向量$\vec{f}$。
而正常的编码结果$D_i$ 能
唯一决定所有输入
包括流控向量$\vec{f}$ 和数据向量$\vec{d}$。

秦et al. \cite{QinTODAES15} 首次提出了能够处理流控机制的对偶综合算法。
该算法首先找到所有的能够被$\vec{o}$唯一决定的$i\in\vec{f}$。
然后推导一个能使得$\vec{d}$ 被$\vec{o}$唯一决定的谓词$valid(\vec{f})$。

\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{nonuniq}
\caption{带有流控机制的编码器}
\label{fig_fc}
\end{figure}

\begin{figure}[b]
\centering
\includegraphics[width=0.9\textwidth]{pipemod1}
\caption{带有流水线和流控机制的编码器}
\label{pipemod}
\end{figure}



同时，
如图\ref{pipemod}所示，
许多编码器
包含流水线级$\vec{stg}^j$ 已将关键的数据路径划分为多个子段$C^j$,
这样有助于提高性能。
类似于$\vec{i}$,
每个流水线级$\vec{stg}^j$ 也可以划分为留空向量$\vec{f}^j$ 和数据向量$\vec{d}^j$。

然而由秦et al. 的算法\cite{QinTODAES15} 产生的解码器并不包含流水线。
这使得其运行速度远低于相应的编码器。
为了解决该问题，
本文提出了一个全新的算法以为此类编码器产生带有流控机制和流水线的解码器。
该算法首先使用秦et al. \cite{QinTODAES15}的算法来寻找$\vec{f}$ 并推导$valid(\vec{f})$。
然后分别通过强制和不强制$valid(\vec{f})$，
已从所有寄存器集合中找到每一个寄存器级$\vec{stg}^j$的$\vec{d}^j$ 和$\vec{f}^j$。
最后通过Jiang et al. \cite{InterpBoolFunction}的算法特征化$\vec{stg}^j$ 和$\vec{i}$的布尔函数。

实验结果表明，
该算法能够为多个工业界的真实编码器正确的产生带有流控和流水线的解码器。

本文剩余部分如下组织。
小节\ref{sec_prem} 介绍相关的背景知识；
小节\ref{sec_framework} 介绍本文算法的整体结构；
小节\ref{sec_pipeinfer} 找到每一个流水线级$\vec{stg}^j$中的$\vec{f}^j$ 和$\vec{d}^j$ 。
小节\ref{sec_char} 为$\vec{stg}^j$ 和$\vec{i}$特征化布尔函数。
小节\ref{sec_exp} 和\ref{sec_relwork} 分别给出实验结果和相关工作。
最后小节\ref{sec_conclude} 给出结论。


\section{背景知识}\label{sec_prem}

% \subsection{Flow control mechanism}\label{subsec_fc}



\subsection{命题逻辑可满足}\label{subsec_SAT}
布尔集合记为$\mathbb{B}=\{0,1\}$。
多个变量组成的向量记为$\vec{v}=(v,\dots)$。
$\vec{v}$ 中的变量个数记为$|\vec{v}|$。
若一个变量$v$ 是$\vec{v}$的成员，
则记为$v\in\vec{v}$；
否则记为$v\notin\vec{v}$。
对于一个变量$v$ 和一个向量$\vec{v}$，
若$v\notin\vec{v}$，
则一个同时包含$v$ 和所有$\vec{v}$ 的成员的新变量记为$v\cup\vec{v}$。
若$v\in \vec{v}$，
则一个包含$\vec{v}$ 的所有成员，但是不包含$v$的
新变量记为$\vec{v}-v$。
对于两个向量$\vec{a}$ 和$\vec{b}$，
则同时包含$\vec{a}$ 和$\vec{b}$ 的所有成员的新向量记为$\vec{a}\cup\vec{b}$。

对于变量集合$V$上的公式$F$，
其命题逻辑可满足问题(SAT)
的目的在于巡展赋值函数$A:V\to \mathbb{B}$，
使得$F$ 能够取值为$1$。
若$A$ 存在则$F$ 是可满足的；
否则是不可满足的。

对于两个布尔命题逻辑公式$\phi_A$ 和$\phi_B$，
若$\phi_A\wedge \phi_B$ 不可满足，
则存在仅引用$\phi_A$ 和$\phi_B$共同变量的公式$\phi_I$ ，
使得$\phi_A\Rightarrow \phi_I$
且$\phi_I\wedge \phi_B$ 不可满足。
$\phi_I$ 称为$\phi_A$ 相对于$\phi_B$的Craig 插值\cite{Craig} 。
可以使用McMillan算法\cite{interp_McMillan} 产生该插值。




\subsection{有限状态机}\label{subsec_fsm}



编码器使用有限状态机$M=(\vec{s},\vec{i},\vec{o},T)$作为模型，
其中包含状态向量$\vec{s}$。
输入向量$\vec{i}$，
输出向量$\vec{o}$，
状态迁移函数$T: \vec{s}\times \vec{i}\to \vec{s}\times \vec{o}$
从当前状态向量和输入向量计算出下一状态向量和输出向量。

$M$ 的行为可以通过展开状态迁移函数进行推导。
状态变量$s\in\vec{s}$, 输入变量$i\in\vec{i}$ 和输出变量$o\in\vec{o}$ 在上述展开序列的第$n$步中
分别记为$s_n$, $i_n$ 和$o_n$。
更进一步的，
在第$n$步中的状态向量，输入向量和输出向量分别记为$\vec{s}_n$, $\vec{i}_n$ 和$\vec{o}_n$。
一个路径是一个序列$<\vec{s}_n,\dots,\vec{s}_m>$ 使得对于所有$n\le j< m$，
有$\exists \vec{i}_j\vec{o}_j (\vec{s}_{j+1},\vec{o}_j)\equiv T(\vec{s}_j,\vec{i}_j)$ 。
而一个环是一个路径$<\vec{s}_n,\dots,\vec{s}_m>$ 使得$\vec{s}_n\equiv \vec{s}_m$。



\subsection{寻找$\vec{f}$的停机算法}\label{subsec_chkextdec}


秦et al. \cite{QinTODAES15} 提出了一个寻找$\vec{f}$ 的停机算法。
该算法通过迭代的调用一个sound和一个complete的算法以最终得到收敛的答案。.
% The first one is an under-approximative one that presented in \ref{subsub_sound},
% while the second one is an over-approximative one presented in \ref{subsub_complete}.
% We will present these two approaches below and show
% that they will eventually converge.

\subsubsection{sound算法}\label{subsub_sound}
如图\ref{fig_pc}a)所示，
在展开的迁移关系上，
一个输入变量$i\in\vec{i}$ 能够被唯一决定，
是指存在$p$, $l$ 和$r$，
使得对于输出序列$<\vec{o}_p,\dots,\vec{o}_{p+l+r}>$的每一个取值，
$i_{p+l}$ 不能同时为0和1。
折等价于公式(\ref{uniqt1})中的$F_{PC}(p,l,r)$的不可满足性。
行1 对应于图\ref{fig_pc}a)中的路径，
而行2 是其拷贝
行3 强制这两个路径的输出相等。
而行4 强制$i_{p+l}$ 不等。
该算法是sound的因为当(\ref{uniqt1}) 不可满足
$i$ 肯定是$\vec{f}$的成员。

\begin{equation}\label{uniqt1}
% \begin{split}
F_{PC}(p,l,r):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\bigwedge_{m=p}^{p+l+r}\vec{o}_m\equiv \vec{o'}_m \\
\wedge& i_{p+l}\equiv 1 \wedge  i'_{p+l}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

\begin{figure}[t]
\begin{center}
\includegraphics[width=\textwidth]{pc}
\end{center}
\caption{sound和complete方法}
  \label{fig_pc}
\end{figure}


%



\subsubsection{complete算法}\label{subsub_complete}
对于上述的$F_{PC}(p,l,r)$ ，
有两种可能性:
\textbf{(1)}. 存在$p$, $l$ 和$r$，使得$i_{p+l}$ 能够被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$ 唯一决定;
或者\textbf{(2)}. $i_{p+l}$ 对于任意$p$, $l$ 和$r$都不能被唯一决定。


对于第一种情形，
通过迭代的增加$p$, $l$ 和$r$，
$F_{PC}(p,l,r)$ 总能够变成不可满足。
而对于第二种情形，
该算法将永不停机。
因此,
为了得到一个停机算法，
我们需要如图\ref{fig_pc}b) 所示的方法去检查第二种情形。
该方法类似于\ref{fig_pc}a) ，
但是在三个状态序列$<\vec{s}_{0},\dots,\vec{s}_{p}>$, $<\vec{s}_{p+1},\dots,\vec{s}_{p+l}>$ 和
$<\vec{s}_{p+l+1},\dots,\vec{s}_{p+l+r}>$上增加了三个约束用于检测环。
该方法形式化的定义于公式(\ref{uniqln})中。
其中最后三行即为我们新加的三个约束。
该方法是complete，
因为当其是可满足的时候，
我们可以通过展开
这三个环来证明第二种情形并断定 $i\notin \vec{f}$。

\begin{equation}\label{uniqln}
% \begin{split}
F_{LN}(p,l,r):=\\
\left\{
\begin{array}{cc}
&F_{PC}(p,l,r)\\
\wedge&\bigvee_{x=0}^{p-1}\bigvee_{y=x+1}^{p} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+1}^{p+l-1}\bigvee_{y=x+1}^{p+l} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+l+1}^{p+l+r-1}\bigvee_{y=x+1}^{p+l+r} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\}
\end{array}
\right\}
% \end{split}
\end{equation}


\subsubsection{通过算法\ref{alg_fofc}找到$\vec{f}$ }\label{subsubsec_findfc}

在行\ref{adduniq},
所有能够被唯一决定的输入$i$ 将被移到$\vec{f}$。
若$F_{LN}(p,l,r)$ 在行\ref{nonuniqres}是可满足的，
所有可满足的输入$i$ 将被移到$\vec{d}$.
该算法的正确性和停机性证明请见\cite{QinTODAES15} 。

\begin{algorithm}[t]
\begin{algorithmic}[1]
\STATE{输入：输入向量$\vec{i}$.}
\STATE{输出：$\vec{f}\subset \vec{i}$, 在此次搜索中找到的最大$p$, $l$ 和$r$ }
\STATE $\vec{f}: = \{\}$;$\vec{d}:= \{\}$;$p$:= 0 ;~$l$:= 0 ;~$r$:= 0 \;
\label{while}\WHILE{$\vec{i}\ne \{\}$}
  \STATE 假设$i\in\vec{i}$\;
  \STATE $p++$; ~ $l++$; ~ $r++$\;
  \IF {$F_{PC}(p,l,r)$ 对于$i$不可满足} 
    \label{adduniq}
    \STATE $\vec{f}:= i\cup\vec{f}$ ; ~
    \STATE $\vec{i}:=\vec{i}-i$\;
  \label{nonuniqres}
  \ELSIF {$F_{LN}(p,l,r)$ 对于$i$可满足}
    \STATE $\vec{d}:=i\cup\vec{d}$ ; ~
    \STATE $\vec{i}:=\vec{i}-i$
  \ENDIF
\ENDWHILE
\RETURN ($\vec{f}$, $p$, $l$, $r$)
\caption{Identifying the flow control vector $\vec{f}$}
\label{alg_fofc}
\end{algorithmic}
\end{algorithm}





\subsection{推导使得$\vec{d}$ 被唯一决定的$valid(\vec{f})$}\label{subsec_infer}

该算法也是由秦et al. \cite{QinTODAES15}提出的。
它首先给出算法\ref{alg_craigchar}，
该算法用于特征化一个函数，覆盖所有能够使得一个布尔关系满足的赋值集合。
然后如图\ref{fig_mono}所示，
算法\ref{alg_craigchar} 被用于特征化函数$\neg FSAT_{PC}(p,l,r)$，
$valid(\vec{f})$的单调递增下估计，
和$\neg FSAT_{LN}(p,l,r)$,
$valid(\vec{f})$的单调递减上估计。
最终我们指出这两者将收敛到$valid(\vec{f})$。
% Please refer to \cite{QinTODAES15} for the proof of its correctness and termination.



\subsubsection{特征化使得一个布尔关系可满足的布尔函数}\label{subsubsec_craig}

对于一个布尔关系$R(\vec{a},\vec{b},t)$，
有$R(\vec{a},\vec{b},0)\wedge R(\vec{a},\vec{b},1)$ 不可满足。
算法\ref{alg_craigchar} 特征化一个布尔寒素$FSAT_R(\vec{a})$，
该函数覆盖且仅覆盖了能使得
$R(\vec{a},\vec{b},1)$ 可满足的所有$\vec{a}$。
行\ref{testsat} 找到$\vec{a}$ 的一个赋值，
尚未被 $FSAT_R(\vec{a})$ 覆盖而且能够使得$R(\vec{a},\vec{b},1)$ 可满足。
行\ref{cofact1}, \ref{cofact2} 和\ref{ab} 使用
McMillan算法\cite{interp_McMillan} 将该赋值放大为$ITP(\vec{a})$。
行\ref{add} 将$ITP(\vec{a})$ 加入$FSAT_R(\vec{a})$。


\begin{algorithm}[t]
\begin{algorithmic}[1]
\STATE{输入：布尔关系$R(\vec{a},\vec{b},t)$}
\STATE{输出：能够使得$R(\vec{a},\vec{b},1)$ 可满足的$FSAT_R(\vec{a})$ }
\label{initcondition}
\STATE $FSAT_R(\vec{a}):= 0$ ;
\label{testsat}
\WHILE { $R(\vec{a},\vec{b},1)\wedge\neg FSAT_R(\vec{a})$ 可满足} 
  \STATE 假设$A:\vec{a}\cup\vec{b}\cup\{t\}\rightarrow \{0,1\}$ 是一个可满足赋值;
\label{cofact1}
  \STATE $\phi_A(\vec{a}):= R(\vec{a},A(\vec{b}),1)$ ;
\label{cofact2}
  \STATE $\phi_B(\vec{a}):= R(\vec{a},A(\vec{b}),0)$ ;
\label{ab}
  \STATE 假设$ITP(\vec{a})$ 是$\phi_A$ 相对于$\phi_B$ 的Craig插值;
\label{add}
  \STATE $FSAT_R(\vec{a}):= ITP(\vec{a}) \vee FSAT_R(\vec{a})$ ;
\ENDWHILE
\RETURN $FSAT_R(\vec{a})$
\caption{$CharacterizingFormulaSAT(R,\vec{a},\vec{b},t)$
% :Characterizing a Boolean function over $\vec{a}$ that can make $R(\vec{a},\vec{b},1)$ satisfiable
\label{alg_craigchar}
\end{algorithmic}
\end{algorithm}

\subsubsection{计算$valid(\vec{f})$的单调递增下估计}\label{subsub_nonloop}
通过将公式(\ref{uniqt1}) 中的$i$替换为算法\ref{alg_fofc}中推导的$\vec{d}$ ，
我们有:

\begin{equation}\label{uniqt1d}
% \begin{split}
F^d_{PC}(p,l,r):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\bigwedge_{m=p}^{p+l+r}\vec{o}_m\equiv \vec{o'}_m \\
\wedge& \vec{d}_{p+l}\ne \vec{d}'_{p+l} \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

% Here,
% $\vec{d}_{p+l}\ne \vec{d}'_{p+l}$ means some bit in $\vec{d}_{p+l}$
% isn't equal to the corresponding bit in $\vec{d}'_{p+l}$.
若$F^d_{PC}(p,l,r)$ 可满足，
则$\vec{d}_{p+l}$ 不能被$<\vec{o}_p,\dots,\vec{o}_{p+l+r}>$唯一决定。
通过收集公式 (\ref{uniqt1d})的第三行，
我们定义$T_{PC}(p,l,r)$ :

\begin{equation}\label{tpc}
% \begin{split}
T_{PC}(p,l,r):=\\
\left\{
\begin{array}{cc}
      &\bigwedge_{m=p}^{p+l+r}\vec{o}_m\equiv \vec{o'}_m \\
\end{array}
\right\}
% \end{split}
\end{equation}

\begin{figure}[b]
\begin{center}
\includegraphics[width=0.5\textwidth]{mono}
\end{center}
\caption{The monotonicity of $FSAT_{PC}(p,l,r)$ and $FSAT_{LN}(p,l,r)$}
  \label{fig_mono}
\end{figure}

通过将$T_{PC}(p,l,r)$ 替换回$F^d_{PC}(p,l,r)$，
我们有：

\begin{equation}\label{fpcq}
% \begin{split}
F'^d_{PC}(p,l,r,t):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge& t\equiv T_{PC}(p,l,r)\\
\wedge& \vec{d}_{p+l}\ne \vec{d'}_{p+l} \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}


很明显$F^d_{PC}(p,l,r)$ 和$F'^d_{PC}(p,l,r,1)$ 是等价的，
我们进一步定义：

\begin{equation}\label{pcdef1}
\vec{a}:=\vec{f}_{p+l}
\end{equation}

\begin{equation}\label{pcdef2}
\vec{b}:=\vec{d}_{p+l}\cup \vec{d'}_{p+l}\cup \vec{s}_0\cup \vec{s'}_0\cup\bigcup_{0\le x\le p+l+r,x\neq (p+l)}(\vec{i}_{x}\cup\vec{i'}_{x})
\end{equation}

因此,
向量$\vec{a}\cup\vec{b}$ 包含所有步的输入向量$<\vec{i}_0,\dots,\vec{i}_{p+l+r}>$ 和$<\vec{i'}_0,\dots,\vec{i'}_{p+l+r}>$。
它同时也包含两个初始状态$\vec{s}_0$ 和$\vec{s'}_0$。
因此$\vec{a}$ 和$\vec{b}$ 能唯一决定$F'^d_{PC}(p,l,r,t)$中$t$ 的取值。
这意味着$R(\vec{a},\vec{b},1)\wedge R(\vec{a},\vec{b},0)$ 是不可满足的。
因此,
对于$p$, $l$ 和$r$的特定组合，
在$\vec{f}_{p+l}$ 上定义且能够使$F'^d_{PC}(p,l,r,1)$ 满足的函数可以通过使用$F'^d_{PC}(p,l,r,t)$, $\vec{a}$ 和$\vec{b}$ 调用算法定义如下：

\begin{equation}\label{fsat_pc}
FSAT_{PC}(p,l,r):=CharacterizingFormulaSAT(F'^d_{PC}(p,l,r,t),\vec{a},\vec{b},t)
\end{equation}

如图\ref{fig_mono}所示，
$\neg FSAT_{PC}(p,l,r)$ 是$valid(\vec{f})$ 的针对
$p$, $l$ 和$r$
单调递增的下估计。
% \end{proposition}




\subsubsection{计算$valid(\vec{f})$的单调递减上估计}\label{subsub_loop}
类似的,
我们定义:

\begin{equation}\label{tln}
% \begin{split}
T_{LN}(p,l,r):=\\
\left\{
\begin{array}{cc}
      &\bigwedge_{m=p}^{p+l+r}\vec{o}_m\equiv \vec{o'}_m \\
\wedge&\bigvee_{x=0}^{p-1}\bigvee_{y=x+1}^{p} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+1}^{p+l-1}\bigvee_{y=x+1}^{p+l} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+l+1}^{p+l+r-1}\bigvee_{y=x+1}^{p+l+r} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\}
\end{array}
\right\}
% \end{split}
\end{equation}



\begin{equation}\label{lndef1}
F'^d_{LN}(p,l,r,t):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
% \wedge& \vec{f}_{p+l}\equiv \vec{f'}_{p+l}\\
\wedge& t\equiv T_{LN}(p,l,r)\\
\wedge& \vec{d}_{p+l}\ne \vec{d'}_{p+l} \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
\end{equation}


\begin{equation}\label{fsat_ln}
FSAT_{LN}(p,l,r):=CharacterizingFormulaSAT(F'^d_{LN}(p,l,r,t),\vec{a},\vec{b},t)
\end{equation}

如图\ref{fig_mono}所示，
$\neg FSAT_{LN}(p,l,r)$ 是$valid(\vec{f})$ 相对于$p$, $l$ 和$r$.的一个单调递减的上估计。



\subsubsection{使用算法\ref{algo_infer}推导$valid(\vec{f})$ }\label{subsub_overal}
\begin{algorithm}[t]
\begin{algorithmic}[1]
\STATE $p$:= $0$;~$l$:= $0$;~$r$:= $0$ \;
\WHILE{ $\neg FSAT_{LN}(p,l,r)\wedge FSAT_{PC}(p,l,r)$ 可满足} 
  \STATE $p$ ++ ;~$l$ ++ ;~$r$ ++ ;
\ENDWHILE
\RETURN {$\neg FSAT_{LN}(p,l,r)$}
\caption{推导$valid(\vec{f}_{p+l})$}
\label{algo_infer}
\end{algorithmic}
\end{algorithm}

该算法迭代的增加$p$, $l$ 和$r$，
直到$FSAT_{PC}(p,l,r)$ 和$FSAT_{LN}(p,l,r)$ 收敛。
其正确性和停机性见\cite{QinTODAES15} 。


\section{算法框架}\label{sec_framework}


\subsection{编码器的一般性模型}
如图\ref{fig_pipeenc}所示，
我们假设编码器包含$n$ 流水线级$\vec{stg}^j$,
其中$0\le j \le n-1$。
每一个流水线级$\vec{stg}^j$ 能够被进一步划分为流控向量$\vec{f}^j$ 和数据向量$\vec{d}^j$。
而输入向量$\vec{i}$，
和\cite{QinTODAES15}一样，
也能被划分为留空向量$\vec{f}$ 和数据向量$\vec{d}$。
如果将组合逻辑块$C^j$ 视为一个函数，
则该编码器可以使用下列等式定义：

\begin{equation}\label{equ_genpipe}
\begin{array}{cccc}
\vec{stg}^0   & := & C^0(\vec{i})         &\\
\vec{stg}^j   & := & C^j(\vec{stg}^{j-1}) & 1\le j\le n-1\\
\vec{o}       & := & C^n(\vec{stg}^{n-1}) &
\end{array}
\end{equation}


\begin{figure}[b]
\begin{center}
\includegraphics[width=\textwidth]{pipemod1}
\end{center}
\caption{包含流水线级和流控机制的一般性编码器模型}
  \label{fig_pipeenc}
\end{figure}



在本文中，
上标始终意味着流水线级,
而下标，,
如小节\ref{subsec_fsm}指出,
始终意味着在展开的迁移关系序列中的步。
例如,
$\vec{stg}^j$ 是第$j$个流水线级。
而$\vec{stg}^j_i$ 该第$j$流水线级
在第$i$步的取值。

\subsection{算法框架}

基于图\ref{fig_pipeenc}所示的编码器结构，
我们算法的框架为：

\begin{enumerate}
 \item 调用算法\ref{alg_fofc} 已将$\vec{i}$ 划分为$\vec{f}$ 和$\vec{d}$。
 \item 调用算法\ref{algo_infer} 以推导能够使得$\vec{d}$
 被唯一决定的$valid(\vec{f})$和其对应的$p$, $l$ 和$r$。
 \item 在小节\ref{sec_pipeinfer},
 找到每一个流水线级$\vec{stg}^j$中的$\vec{f}^j$ 和$\vec{d}^j$ 。
 \item 在小节\ref{sec_char},
 为每一个流水线级$\vec{stg}^j$
 和输入向量 $\vec{i}$特征化布尔函数。
\end{enumerate}



\section{推导流水线结构}\label{sec_pipeinfer}


\subsection{压缩$r$ 和$l$}\label{reduceing}

\begin{algorithm}[t]
\begin{algorithmic}[1]
\FOR{$r':=r \to 0$} 
\label{testr_1}
  \IF{$r'\equiv 0$ or $F_{PC}(p,l,r'-1)\wedge valid(\vec{f}_{p+l})$ 对于某些$i\in \vec{i}$可满足} 
    \STATE break
  \ENDIF
\ENDFOR
\RETURN $r'$
\caption{压缩$r$}
\label{algo_remove2}
\end{algorithmic}
\end{algorithm}

由于算法\ref{algo_infer} 同时增加$p$, $l$ 和$r$ ，
因此$l$ 和$r$存在一定程度的冗余。
因此我们需要首先在算法\ref{algo_remove2}中压缩$r$。


在行\ref{testr_1}，
我们将推导的谓词$valid(\vec{f})$ 和$F_{PC}(p,l,r'-1)$与在一起。
当该公式可满足时，
则$r'$ 是最后一个使得$F_{PC}(p,l,r')\wedge valid(\vec{f}_{p+l})$ 不可满足的值，
我们将其直接直接返回。
另一方面，
当$r'\equiv 0$，
$F_{PC}(p,l,0)$ 肯定已经在上一个迭代中被测试，
且结果为不可满足。
此时我们直接返回$0$。


这样,
我们从算法\ref{algo_remove2}得到了一个压缩的$r$，
使得$\vec{i}_{p+l}$ 可以被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$唯一决定。

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.5\textwidth]{pc1}
\end{center}
\caption{使用削减的输出序列恢复输入}
  \label{fig_pc1}
\end{figure}

我们进一步要求:
\begin{enumerate}
 \item 如图\ref{fig_pc1}所示,
 $l$ 可以被削减为0。
 这意味着$\vec{i}_{p}$ 可以被$<\vec{o}_{p},\dots,\vec{o}_{p+r}>$唯一决定。
 即所有的未来输出。
 \item 上述的输出序列$<\vec{o}_{p},\dots,\vec{o}_{p+r}>$
 能被进一步压缩为$\vec{o}_{p+r}$。
 这意味着只需$\vec{o}_{p+r}$ 即可唯一决定$\vec{i}_p$。
\end{enumerate}

检验这两个要求等价于
检查$F'_{PC}(p,r)\wedge valid(\vec{f}_{p+l})$的不可满足性
其中$F'_{PC}(p,r)$ 定义如下：

\begin{equation}\label{uniqt11}
% \begin{split}
F'_{PC}(p,r):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\vec{o}_{p+r}\equiv \vec{o'}_{p+r} \\
\wedge& i_{p}\equiv 1 \wedge  i'_{p}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}


该要求看起来远远强于(\ref{uniqt1})。
我们将在实验结果中指出他们总能够满足。



\subsection{推导流水线结构}\label{subsec_inferstage}

现在,
基于上述推导的$p$ 和$r$,
我们将公式(\ref{uniqt11}) 中的$F'_{PC}$推广到下面定义的更广泛的形式。
它能够检查任意变量$v$ 在步$j$
能否被向量$\vec{w}$ 在步$k$唯一决定。
现在$v$ 和$\vec{w}$ 可以使输入，输出或者状态向量。

\begin{equation}\label{uniqt2}
% \begin{split}
F''_{PC}(p,r,v,j,\vec{w},k):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\vec{w}_{k}\equiv \vec{w'}_{k} \\
\wedge& v_{j}\equiv 1 \wedge  v'_{j}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

很明显,
当$F''_{PC}(p,r,v,j,\vec{w},k)$ 不可满足时，
$\vec{w}_k$ 能唯一决定$v_j$.

对于$0\le j\le n-1$,
在第$j$流水线级$\vec{stg}^j$,
其留空向量$\vec{f}^j$ 包含所有的
能够在第$j-((n-1)-(p+r))$-th 步被$\vec{o}$
在第$p+r$步唯一决定的状态变量$s\in \vec{s}$。
注意在这里不需要约束$valid(\vec{f}_p)$。
这可以形式化的定义为:

\begin{equation}\label{stgn_fj}
\vec{f}^{j} :=
 \left\{
 s\in \vec{s} ~|
\begin{array}{cc}
 F''_{PC}(p,r,s,j-D,\vec{o},p+r)\\
 ~is~unsatisfiable
\end{array}
\right\}
\end{equation}

其中:

\begin{equation}\label{stgn_def}
\begin{array}{ccc}
% S             & := & \vec{s}/\bigcup_{j<k\le n-2}\vec{stg}^{k}\\
D             & := & (n-1)-(p+r)\\
\end{array}
\end{equation}

而在第$j$流水线级$\vec{stg}^j$中的数据向量$\vec{d}^j$
包含能够在第$j-((n-1)-(p+r))$步被
$\vec{o}$ 在第$p+r$步唯一决定的所有$s\in \vec{s}$。
注意这里我们需要强制$valid(\vec{f}_p)$。
这可以被形式化的定义为:

\begin{equation}\label{stgn_dj}
\vec{d}^{j} :=
 \left\{
 s\in \vec{s} ~|
 \begin{array}{cc}
 F''_{PC}(p,r,s,j-D,\vec{o},p+r)\wedge valid(\vec{f}_p)\\
 ~is~unsatisfiable
 \end{array}
\right\}
\end{equation}


\section{特征化流水线级和输入的布尔函数}\label{sec_char}
\subsection{特征化最后一个流水线级的布尔函数}

从公式(\ref{stgn_fj})可知,
每个寄存器$s\in \vec{f}^{n-1}$ 能过被$\vec{o}$ 在第$p+r$步唯一决定。
也就是,
$F''_{PC}(p,r,s,p+r,\vec{o},p+r)$ 不可满足且可以划分为:

\begin{equation}
 \phi_A :=
 \left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge& s_{p+r}\equiv 1
\end{array}
\right\}
\end{equation}

\begin{equation}
% \begin{split}
\phi_B :=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\vec{o}_{p+r}\equiv \vec{o'}_{p+r} \\
\wedge& s'_{p+r}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

因为$F''_{PC}(p,r,s,p+r,\vec{o},p+r)$ 等价于$\phi_A \wedge \phi_B$,
so $\phi_A \wedge \phi_B$ is unsatisfiable.
And the common variables of $\phi_A$ and $\phi_B$ is $\vec{o}_{p+r}$.

According to \cite{InterpBoolFunction},
a Craig interpolant $\phi_I$ of $\phi_A$ with respect to $\phi_B$ can be constructed,
which refer only to $\vec{o}_{p+r}$,
and covers all the valuations of $\vec{o}_{p+r}$ that can make $s_{p+r}\equiv 1$.
At the same time,
$\phi_I\wedge \phi_B$ is unsatisfiable,
which means $\phi_I$ covers nothing that can make $s_{p+r}\equiv 0$.

Thus,
$\phi_I$ can be used as the decoder's Boolean function
that recovers $s\in \vec{f}^{n-1}$ from $\vec{o}$.

By replacing $F''_{PC}(p,r,s,p+r,\vec{o},p+r)$ with $F''_{PC}(p,r,s,p+r,\vec{o},p+r)\wedge valid(f_p)$,
we can similarly characterize the Boolean function that recovers $s\in\vec{d}^{n-1}$.

\subsection{Characterizing the Boolean functions recovering other pipeline stages}
According to Figure \ref{fig_pipeenc},
% Similar to last subsection,
$\vec{f}^j$ at the $j-D$-step can be uniquely determined by $\vec{stg}^{j+1}$ at the $j-D+1$-th step.
So we can partition the unsatisfiable formula $F''_{PC}(p,r,s,j-D,\vec{stg}^{j+1},j-D+1)$
 into the following two equations:

\begin{equation}
 \phi_A :=
 \left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge& s_{j-D}\equiv 1
\end{array}
\right\}
\end{equation}

\begin{equation}
% \begin{split}
\phi_B :=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\vec{stg}^{j+1}_{j-D+1}\equiv \vec{stg'}^{j+1}_{j-D+1} \\
\wedge& s'_{j-D}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

Again,
a Craig interpolant $\phi_I$ of $\phi_A$ with respect to $\phi_B$ can be constructed,
and used as the decoder's Boolean function that recovers $s\in\vec{f}^{j}$ from $\vec{stg}^{j+1}$.

Similarly,
by replacing $F''_{PC}(p,r,s,j-D,\vec{stg}^{j+1},j-D+1)$  with
$F''_{PC}(p,r,s,j-D,\vec{stg}^{j+1},j-D+1)\wedge valid(f_p)$ ,
we can characterize the Boolean function that recovers $s\in\vec{d}^{j}$ from $\vec{stg}^{j+1}$.

\subsection{Characterizing the Boolean functions recovering the encoder's input variables}

According to Figure \ref{fig_pipeenc},
$\vec{f}$ at the $p$-step can be uniquely determined by $\vec{stg}^0$ at the $p$-th step.
$F''_{PC}(p,r,i,p,\vec{stg}^0,p)$ is unsatisfiable and can be partitioned into :

\begin{equation}
% \begin{split}
\phi_A:=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge& i_{p}\equiv 1
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

\begin{equation}
% \begin{split}
\phi_B:=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\vec{stg}^0_p\equiv \vec{stg'}^0_p \\
\wedge& i'_{p}\equiv 0
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
% \wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

Again,
the Craig interpolant $\phi_I$ of $\phi_A$ with respect to $\phi_B$
can be used as the decoder's Boolean function that recovers $i\in\vec{f}$ from $\vec{stg}^0$.

Similarly,
by replacing $F''_{PC}(p,r,i,p,\vec{stg}^0,p)$ with $F''_{PC}(p,r,i,p,\vec{stg}^0,p)\wedge valid(\vec{f}_p)$,
we can characterize the Boolean function that recovers $i\in\vec{d}$ from $\vec{stg}^0$.



\section{Experimental results}\label{sec_exp}
We have implemented these algorithms in OCaml language,
and solved the generated CNF formulas with MiniSat 1.14 \cite{EXTSAT}.
All experiments have been run on a server with 16 Intel Xeon E5648 processors at 2.67GHz,
192GB memory, and CentOS 5.4 Linux.
% All these experimental results and programs can be downloaded
% from https://github.com/shengyushen/compsyn.

% \subsection{Benchmarks}
%  shows all benchmarks used in this paper.
% They come from \cite{ShenTCAD12}.
%  \item The benchmark package sent to us by Liu, the author of \cite{LiuTCAD12}.
%  So there may be some overlap between (2) and (3).
% \end{enumerate}

\subsection{Comparing timing and area}
Table \ref{tab_bench} shows the benchmarks used in this paper.
% They are listed in the order of circuit area.
The 2nd and 3rd column show respectively the number of inputs, outputs and registers of each benchmark.
The 4th column shows the area of the encoder when mapped to LSI10K library with Design Compiler.
% We use Design compiler here instead of ABC \cite{ABC} used by other researchers
% because ABC can not read in verilog files with registers generated by our algorithms.
In this paper,
all area and delay are obtained in the same setting.
% we can compare them to that of \cite{LiuTCAD12}.



\begin{table*}[t]
\caption{Benchmarks and experimental results}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
 Names     & \multicolumn{4}{|c|}{The encoders}                                  &   \multicolumn{3}{|c|}{decoder gener-}             &   \multicolumn{3}{|c|}{decoder gener-} \\
           & \multicolumn{4}{|c|}{}                                              &   \multicolumn{3}{|c|}{ated by \cite{ShenTCAD11}}  &   \multicolumn{3}{|c|}{ated by this paper} \\\cline{2-11}
           &    \#   &   \#    &area  & Description                             &run  &delay&area                                     &run  &delay&area \\
           & in/out  &  reg    &      &   of Encoders                            &time &(ns) &                                        &time &(ns) &    \\\hline\hline
 pcie      & 10/11   & 23      & 326  &PCIE 2.0 \cite{pcie21}                    &0.37 &7.20 &624                                     &8.08 & 5.89&652 \\\hline
 xgxs      & 10/10   & 16      & 453  &     Ethernet clause 48 \cite{IEEE8023_S4}&0.21 &7.02 &540                                     &4.25 & 5.93&829 \\\hline
 t2eth     & 14/14   & 49      & 2252 &    Ethernet clause 36 \cite{IEEE8023_S4} &12.7 &6.54 &434                                     &430.4& 6.12&877 \\\hline
scrambler  &64/64    & 58      & 1034 & inserting 01 flipping                    &     \multicolumn{6}{|c|}{no pipeline }\\\cline{1-5}
 xfi       & 72/66   & 72      & 7772 &     Ethernet clause 49 \cite{IEEE8023_S4}&     \multicolumn{6}{|c|}{stages found}\\\hline
\end{tabular}\label{tab_bench}
\end{table*}


% \begin{table}[t]
% \caption{Experimental results}
% \begin{tabular}{|c|c|c|c|c|c|c|c|}
% \hline
%
%  Na-
%  mes
%
%  pcie      &0.37 &7.20 &624 &3.57 & 5.89&652 &9/12\\\hline
%  xgxs      &0.21 &7.02 &540 &1.57 & 5.93&829 &13\\\hline
%  t2eth     &12.7 &6.54 &434 &47.2 & 6.12&877 &8/8/10/20\\\hline
%  scr.      &     \multicolumn{7}{|c|}{no pipeline }\\\cline{1-1}
%  xfi       &     \multicolumn{7}{|c|}{structure found}\\\hline
% \end{tabular}\label{tab_res}
% \end{table}


% Table \ref{tab_res} compares the old algorithm from \cite{ShenTCAD11} to this paper's algorithm.
The 6th to 8th columns show respectively the run time of \cite{ShenTCAD11}'s algorithm to generate the decoder without pipeline,
and the delay and area of the generated decoder.
While the 9th to 11th columns show respectively the run time of this paper's algorithm to generate the pipelined decoder,
and the delay and area of the generated decoder.
% The last column shows the number of registers in each pipeline stage.

Comparing the 7th and the 10th column indicates that
the decoders' delay have been significantly improved.
% And the the last column shows that there actually exist very deep pipeline,
% especially the t2eth with 4 pipeline stages.

One thing that is a little bit surprise is,
the two largest benchmarks scrambler and xfi do not have pipeline stages inside.
We study their code and confirm that this is true.
Their area are so large because they use much wider datapaths with 64 to 72 bits.
% Please refer to IEEE 802.3ae clause 49 \cite{IEEE8023_S4}  for more details.

\subsection{Inferred pipeline stages of pcie}

For the benchmark pcie,
there are two pipeline stages,
whose flow control vector and data vector are respectively shown in Table \ref{tab_pcie}.

\begin{table}[t]
\centering
\caption{Inferred pipeline stages of pcie}
\begin{tabular}{|c|c|c|c|}
\hline
                       & input                  & pipeline stage 0          &  pipeline stage 1    \\\hline\hline
flow control           &CNTL\_TXEnable\_P0      & InputDataEnable\_P0\_reg  & OutputData\_P0\_reg[9:0]\\
vector                 &                        &                           & OutputElecIdle\_P0\_reg \\\hline
flow control           &CNTL\_TXEnable\_P0      & InputDataEnable\_P0\_reg  & true \\
predicate              &                        &                           &  \\\hline
data vector            &TXDATA[7:0]             & InputData\_P0\_reg[7:0]   & \\
                       &TXDATAK                 & InputDataK\_P0\_reg       & \\\hline
\end{tabular}\label{tab_pcie}
\end{table}


One issue to be noticed that is the data vector at pipeline stage 1 is empty,
while all registers in that stages are recognized as flow control vector.
We inspect the encoder's source code and find that these registers are
directly feed to output.
So they can actually be uniquely determined by $\vec{o}$.
This doesn't affect the correctness of the generated decoder,
because the functionality of flow control vector never depend on the inferred flow control predicate.


\subsection{Inferred pipeline stages of xgxs}


For the benchmark xgxs,
there are only 1 pipeline stage,
whose flow control vector and data vector are respectively shown in Table \ref{tab_xgxs}.

\begin{table}[b]
\centering
\caption{Inferred pipeline stages of xgxs}
\begin{tabular}{|c|c|c|}
\hline
                       & input                  &  pipeline stage 0    \\\hline\hline
flow control vector    &bad\_code               & bad\_code\_reg\_reg\\\hline
flow control predicate &!bad\_code              & !bad\_code\_reg\_reg \\\hline
data vector            &encode\_data\_in[7:0]   &ip\_data\_latch\_reg[2:0] \\
                       &konstant                &plus34\_latch\_reg     \\
                       &                        &data\_out\_latch\_reg[5:0]\\
                       &                        &konstant\_latch\_reg   \\
                       &                        &kx\_latch\_reg         \\
                       &                        &minus34b\_latch\_reg   \\\hline
\end{tabular}\label{tab_xgxs}
\end{table}


\subsection{Inferred pipeline stages of t2ether}


\begin{table}[t]
\centering
\caption{Inferred pipeline stages of t2ether}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
                       & input                        & pipeline                  &  pipeline          &  pipeline       &  pipeline               \\
                       &                              & stage 0                   &  stage 1           &  stage 2        &  stage 3                \\\hline\hline
flow                   & tx\_enc\_ctrl\_sel[3:0]      &qout\_reg\_0\_8            & qout\_reg\_0\_9    &qout\_reg[9:0]\_2&qout\_reg[7:1]\_3        \\
control                &                              &qout\_reg\_2\_4            & qout\_reg\_1\_5    &                 &qout\_reg\_8\_1          \\
vector                 &                              &qout\_reg\_1\_4            & qout\_reg\_2\_5    &                 &qout\_reg\_9\_1          \\
                       &                              &                           & qout\_reg\_0\_10   &                 &qout\_reg\_3\_4          \\
                       &                              &                           &                    &                 &qout\_reg\_0\_4          \\
                       &                              &                           &                    &                 &qout\_reg\_3\_5          \\
                       &                              &                           &                    &                 &qout\_reg\_0\_7          \\
                       &                              &                           &                    &                 &sync1\_reg1              \\
                       &                              &                           &                    &                 &sync1\_reg               \\
                       &                              &                           &                    &                 &Q\_reg1                  \\
                       &                              &                           &                    &                 &Q\_reg                         \\\hline
data                   &txd[7:0]                      &qout\_reg[7:0]             &qout\_reg[7:0]\_1   &                 &                         \\
vector                 &                              &                           &                    &                 &                         \\\hline
\end{tabular}\label{tab_t2ether}
\end{table}


For the benchmark t2ether,
there are four pipeline stages shown in Table \ref{tab_t2ether}.
The control flow predicates are fairly complex,
so we list them below instead of in Table \ref{tab_t2ether}.
The input control flow predicate $f$ is :
\begin{multline}
\begin{array}{l}
( tx\_enc\_ctrl\_sel[2]~\&~tx\_enc\_ctrl\_sel[3] ) | \\
( tx\_enc\_ctrl\_sel[2]~\&~!tx\_enc\_ctrl\_sel[3]~\&~!tx\_enc\_ctrl\_sel[0]~\&~tx\_enc\_ctrl\_sel[1] ) | \\
( !tx\_enc\_ctrl\_sel[2]~\&~tx\_enc\_ctrl\_sel[3] ) | \\
( !tx\_enc\_ctrl\_sel[2]~\&~!tx\_enc\_ctrl\_sel[3]~\&~tx\_enc\_ctrl\_sel[0] )
\end{array}
\end{multline}

The flow control predicate $valid(\vec{f}^0)$ for the 0-th pipeline stage is :
\begin{multline}
\begin{array}{l}
( qout\_reg\_2\_4~\&~qout\_reg\_1\_4~\&~!qout\_reg\_0\_8) | \\
( !qout\_reg\_2\_4~\&~qout\_reg\_0\_8)
\end{array}
\end{multline}

The flow control predicate $valid(\vec{f}^1)$ for the 1-th pipeline stage is :

\begin{multline}
\begin{array}{l}
( qout\_reg\_2\_5~\&~qout\_reg\_1\_5~\&~qout\_reg\_0\_10~\&~!qout\_reg\_0\_9) | \\
( qout\_reg\_2\_5~\&~qout\_reg\_1\_5~\&~!qout\_reg\_0\_10) | \\
( qout\_reg\_2\_5~\&~!qout\_reg\_1\_5~\&~!qout\_reg\_0\_10) | \\
( !qout\_reg\_2\_5~\&~qout\_reg\_0\_10~\&~qout\_reg\_0\_9) | \\
( !qout\_reg\_2\_5~\&~!qout\_reg\_0\_10)
\end{array}
\end{multline}


The flow control predicates $valid(\vec{f}^2)$ and $valid(\vec{f}^3)$ for the last two pipeline stages are all $true$.































\section{RELATED PUBLICATIONS}\label{sec_relwork}
%\subsection{Complementary Synthesis}
%%Complementary synthesis is an emerging new research topic,
%%there are only two papers that discuss this problem.
%
%The concept of complementary synthesis was first proposed by us\cite{ShengYuShen:iccad09} in ICCAD 2009.
%Its major shortcomings are that it is incomplete,
%and its run-time overhead of building decoder is too large.
%
%The incomplete problem has been addressed by \cite{ShengYuShen:fmcad10}, while \cite{ShengYuShen:tcad} addresses the second shortcoming by simplifying the SAT instance with unsatisfiable core extraction before building decoders.

\subsection{Complementary synthesis}\label{subsec_compsyn_relat}
The first complementary synthesis algorithm was proposed by \cite{ShenICCAD09}.
It checks the decoder's existence by iteratively increasing the bound of unrolled transition function sequence,
and generates the decoder's Boolean function by enumerating all satisfying assignments of the decoder's output.
Its major shortcomings are that it may not halt and it is too slow
in building the decoder.

Shen et al.\cite{ShenTCAD11} and Liu et al.\cite{LiuICCAD11} tackled the halting problem independently by searching for loops in the state sequence,
while the runtime overhead problem was addressed in \cite{ShenTCAD12,LiuICCAD11} by Craig interpolant\cite{interp_McMillan}.

Shen et al.\cite{ShenTCAD12} automatically inferred an assertion for configuration pins,
which can lead to the decoder's existence.
% It can be seen as a special case of Algorithm \ref{algo_pcln} in Section \ref{sec_infer},
% with the restriction that the inferred assertion must hold on all cycles,
% to prevent the encoder from leaving the unique state set.

Qin et al. \cite{QinTODAES15}
proposed the first algorithm can handle encoder with flow control mechanism.
But it can not handle pipeline stages.

Tu and Jiang \cite{TuDAC13} proposed a break-through algorithm
that recover the encoder's input by considering its initial and reachable states.
% based on property directed reachability analysis\cite{BradleyVMCAI11,EenFMCAD11}
% that can take the encoder's initial state into consideration,
% so that the infinite history of the encoder and the decoder can be used to generate the decoder's output.
% This algorithm can handle some special encoders that cannot be handled by the state-of-the-art algorithms.
% But for the encoders with flow control mechanism used in our experiments,
% our algorithm is enough,
% and therefore we have not implemented their algorithm in our framework.


\subsection{Program inversion}\label{subsec_proinv}
According to Gulwani \cite{dim_syn},
program inversion involves deriving a program $P^{-1}$
that negates the computation of a given program $P$.
So,
the definition of program inversion is very similar to complementary synthesis.

The initial work on deriving program inversion used proof-based approaches\cite{prog_inv},
which could handle only very small programs and very simple syntax structures.

Gl\"{u}ck et al. \cite{mtd_autoProginv} inverted first-order functional programs
by eliminating nondeterminism with LR-based parsing methods.
But,
the use of functional languages in that work is incompatible with our complementary synthesis.

{Srivastava et al. \cite{prog_inv_rev,program_inversion_11} assumed that an inverse program was typically related to the original program,
and so the space of possible inversions can be inferred by automatically
mining the original program for expressions, predicates, and control flow.
This is somewhat similar to our approach in inferring the pipeline stages.
This algorithm inductively rules out invalid paths that cannot fulfill the requirement of inversion
to narrow down the space of candidate programs until only the valid ones remain.
% So,
% it can only guarantee the existence of a solution,
% but not the correctness of this solution if its assumptions do not hold.

% \subsection{The completeness of bounded model checking}\label{subsec_bmc_relate}
% Bounded model checking(BMC) \cite{bmc_tacas99} is a model checking technology that considers only paths of limited length.
% So it is an incomplete algorithm.
% Many researchers have tried to find complete approaches for BMC.
%
% One line of research\cite{bmc_tacas99,RecDiam} tried to find out a bound $b$,
% which can guarantee the correctness of a specification,
% if the specification is correct on all paths that are shorter than $b$.
% Line 8 of Algorithm \ref{algo_pcln} finds out the value of $p$,$d$ and $l$ that can prove the non-existence of the decoder,
% which is similar to \cite{bmc_tacas99,RecDiam}.
%
% The other line of research\cite{kind_tacas99} tried to find a bound for induction,
% such that the correctness of a specification within any bound $b$ implies the correctness on bound $b+1$.
% Our algorithm proves the non-existence of the decoder by unfolding loops.
% This is similar to finding induction patterns \cite{kind_tacas99}.

% \textbf{This paper achieves completeness without following these two approaches.
% Instead,
% it defines two complement uniqueness conditions,
% $LP$ and $LL$,
% and find out proper algorithms to check them.}

%\subsection{Temporal Logic Synthesis}
%%Automatically synthesis of program from logic specification is first identified as Church's problem in 1962\cite{LOGARTHAUTO}.
%%Some early researches \cite{SLVSQFSS,AUTOINF} solve this problem by reducing it to checking emptiness of tree automata.
%
%The temporal logic synthesis was first addressed by Clarke et al.\cite{DSGSYNTMPLG} and Manna et al. \cite{SYNTMPLGSPC}.
%But Pnueli et al. \cite{SYNRCTVMD} pointed out that the complexity of LTL synthesis is double exponent.
%%This high complexity drives researchers turning their focus to find smaller but still useful subset of temporal logic,
%%such that synthesis problem can be solved with lower complexity.
%
%One line of research \cite{CNTLSYNTMDAUTO,DTMGENGMELTL,SYNRCTVDES} focuses on the so-called generalized reactive formulas of the form:
%$(\square \lozenge p_1 \wedge \cdots \square \lozenge p_m) \to (\square \lozenge q_1 \wedge \cdots \square \lozenge q_n)$.
%Complexity of solving synthesis problem for such formula is $O(N^3)$.
%
%The other line of research focuses on finding efficient algorithm \cite{SYNCNTLBNDRPN}
%for expensive safra determination algorithm \cite{CMPLXAUTO} on an useful formula subset,
%or just avoiding it\cite{NEWALGSTRGSYN}.
%
%%Yet another approach is antichain\cite{ANTICHAIN},
%%which reduces the expensive state set computation to computation on maximal and minimal elements of lattice.
%
%Based on these research works,
%some tools\cite{ANZU} that can handle small temporal formulas have been developed.
%
%All these works assume a hostile environment,
%which seems too restrictive for many applications.
%So Fisman et al. \cite{rationalsyn_tacas10}, Chatterjee et al. \cite{assguasyn_tacas07} and Ummels et al. \cite{ralgame_istta06} proposed rational synthesis algorithm,
%which assumes that each agents act to achieve their own goals instead of failing each other.


% \subsection{Protocol converter synthesis}
% Protocol converter synthesis is a process that automatically generates a translator between two different communication protocols.
% This is relevant to our work,
% because both focus on synthesizing communication circuits.
%
% Avnit et al. \cite{converter_date08,converter_todeas09} first defined a general model for describing different protocols,
% and then provided an algorithm to decide
% whether there is some functionality of a protocol that cannot be translated into another.
% Finally,
% they synthesized a translator by computing the greatest fixed point for the update function of the buffer's control states.
% Latter,
% they \cite{converter_date09} improved their algorithm with a more efficient design space exploration algorithm.


\section{Conclusions}\label{sec_conclude}
This paper proposes the first complementary synthesis algorithm that
can handle encoders with pipeline stages and flow control mechanism.
Experimental result indicates that the proposed algorithm can always
correctly generate pipelined decoder with flow control mechanism.


