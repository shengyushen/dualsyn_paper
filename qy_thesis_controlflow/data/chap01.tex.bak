% !Mode:: "Tex:UTF-8"
\chapter{绪论}
\label{chap:1}

通讯和多媒体应用是半导体工业的主要推动力。
这两个领域日新月异的发展，
带来了对传输带宽永无止境的追求。
常见的高性能传输协议，
如以太网\upcite{IEEE8023_S4}、InfiniBand\upcite{InfiniBand}和PCI Express\upcite{pcie21}等，
其单通道带宽从本世纪初的3.125Gbps增长到目前的25Gbps。

为了克服在高频信号衰减方面的挑战，
每一代新的传输标准都会采用全新的编码方案。
因此，在通讯和多媒体芯片设计项目中，
最为关键且困难的工作之一是设计和验证特定的物理层编码器和解码器。
针对这一关键而困难的工作，
工业界常见的设计方法仍然停留在简单地手工编写代码，
并使用动态模拟器进行验证的阶段。

而随着传输带宽的进一步提升，
对于编码后信号01平衡和游程长度的统计特性要求也日益严格\upcite{encode6466}。
这就导致了在编码器中引进了更为复杂的，
包含大量异或操作的线性移位寄存器组，
如以太网标准clause 49的64/66加扰器\upcite{encode6466}和PCI Express标准的128/130编码器\upcite{pcie}。
大量的异或操作使得编码器的映射表非常不规则，
包含的corner case的数量随编码长度指数增长。
这就对传统的动态模拟验证方法的完备性提出了严峻挑战。

为此，
国防科技大学的沈胜宇于2009年首次提出了对偶综合的概念和基本的算法实现\upcite{ShenICCAD09}，
以从一个通讯协议的编码器源代码中，
自动产生其对应的解码器代码。
以此为起点，
集成电路设计自动化领域的研究者们在该领域取得了大量的研究成果\upcite{ShenICCAD09,ShenTCAD10,ShenTCAD11,ShenICCAD11,ShenTCAD12,LiuICCAD11,LiuTCAD12,TuDAC13}。

在本章的剩余部分中，
我们将首先在小节\ref{sec_back}介绍相关的背景知识。
然后在小节\ref{sec_now}详细描述目前在该领域的研究成果。
然后在小节\ref{sec_whiteboxtodo}介绍基于白盒模型的对偶综合的研究意义和所面临的挑战。
最后在小节\ref{sec_contest_innov}介绍本文的研究内容和创新点。

\section{背景知识}\label{sec_back}
本节将给出相关的背景知识。

\subsection{基本记法}
布尔集合记为$B=\{0,1\}$。
多个变量组成的向量记为$\vec{v}=(v,\dots)$。
$\vec{v}$中的变量个数记为$|\vec{v}|$。
如果$v$是$\vec{v}$的成员，
则记为$v\in\vec{v}$；
否则$v\notin\vec{v}$。
对于变量$v$和向量$\vec{v}$，
如果$v\notin\vec{v}$，
则同时包含$v$和所有$\vec{v}$的成员的新向量记为$v\cup\vec{v}$。
如果$v\in \vec{v}$，
则包含所有$\vec{v}$的成员而不包含$v$的新向量记为$\vec{v}-v$。
对于两个向量$\vec{a}$和$\vec{b}$，
包含$\vec{a}$和$\vec{b}$的所有成员的新向量记为$\vec{a}\cup\vec{b}$。
向量$\vec{v}$的赋值集合记为$[\![\vec{v}]\!]$。
例如：
$[\![(v_1,v_2)]\!]=\{(0,0),(0,1),(1,0),(1,1)\}$。

在变量集合$V$上的布尔逻辑公式$F$是通过以下连接符连接$V$上的变量得到的：
包括$\neg$， $\wedge$，$\vee$和$\Rightarrow$，
他们分别代表着求反，与，或和蕴含操作。

\subsection{命题逻辑可满足性问题}

对在变量集合$V$上的布尔逻辑公式$F$，
命题逻辑可满足问题(缩写为SAT)
意味着寻找$V$的赋值函数$A:V\to B$，
使得$F$ 可以取值为$1$。
如果存在这样的赋值函数$A$，
则$F$ 是可满足的；
否则，
是不可满足的。

一个寻找上述赋值函数$A$的计算机程序称为SAT 求解器，
常见的SAT求解器包括Zchaff\upcite{CHAFF}，
Grasp\upcite{grasp}，
Berkmin\upcite{BERKMIN}，
和MiniSat\upcite{EXTSAT}。


通常，
SAT 求解器要求有待求解的公式使用合取范式(CNF)表示，
其中一个公式是一个短句集合的合取，
一个短句是一个文字集合的析取，
一个文字是一个变量或者其反。
一个使用CNF 格式表示的公式通常也称为SAT 实例。


从文献\upcite{EFFSATUSMCCO}可知，
对于函数$f(v_1\dots v\dots v_n)$，
针对变量$v$的\textbf{正余因子}(cofactor)和\textbf{负余因子}分别是$f_{v\equiv 1}=f(v_1\dots 1\dots v_n)$ 和$f_{v\equiv 0}=f(v_1\dots 0\dots v_n)$。
而\textbf{余因子化}则代表着将1或者0赋予$v$以得到$f_{v\equiv 1}$ 和$f_{v\equiv 0}$。

给定两个布尔逻辑公式$\phi_A$ 和$\phi_B$，
若$\phi_A\wedge \phi_B$ 不可满足，
则存在仅使用了$\phi_A$ 和$\phi_B$共同变量的公式$\phi_I$ ，
 使得$\phi_A\Rightarrow \phi_I$且
$\phi_I\wedge \phi_B$不可满足。
$\phi_I$ 被称为$\phi_A$针对$\phi_B$的Craig插值\upcite{Craig}。
$\phi_I$可以使用McMillan算法\upcite{interp_McMillan}得到。
Craig插值通常被用于产生$\phi_A$的上估计。


\subsection{MiniSat 求解器的递增求解机制}\label{subsec_incsat}

本文中，
我们使用MiniSat 求解器\upcite{EXTSAT} 求解所有CNF公式。
和其他基于冲突学习机制\upcite{CONFLICTLEARN}的SAT求解器类似，
MiniSat 从在搜索中遇到的冲突中产生学习短句，
并记录他们以避免类似的冲突再次出现。
该机制能够极大的提升SAT求解器的性能。

在许多应用中，
经常存在一系列紧密关联的CNF公式。
如果在一个CNF公式求解过程中得到的学习短句能够被其他CNF公式共享，
则所有CNF公式的求解速度都能够得到极大的提升。

MiniSat 提供了一个增量求解机制以共享这些学习短句。
该机制包括两个接口函数：
\begin{enumerate}
\item
$addClause(F)$ 用于将一个CNF公式$F$ 添加到MiniSat的短句数据库，
以用于下一轮求解。
\item
$solve(A)$ 接收一个文字集合$A$作为假设，
并求解CNF 公式$F\wedge \bigwedge_{a\in A} a$。
其中$F$是在$addClause$中被加入短句数据库的CNF公式。
\end{enumerate}


\subsection{有限状态机}\label{subsec_fsm}

如图\ref{c2_fsm}a)所示，
本文中编码器使用有限状态机$M=(\vec{s},\vec{i},\vec{o},T)$作为模型。
一个状态机包括状态变量向量$\vec{s}$，
输入变量向量$\vec{i}$，
输出变量向量$\vec{o}$，
和迁移函数$T: [\![\vec{s}]\!]\times [\![\vec{i}]\!]\to [\![\vec{s}]\!]\times [\![\vec{o}]\!]$。
其中$T$用于从当前状态变量向量$\vec{s}$和输入变量向量$\vec{i}$计算出下一状态变量向量$\vec{s}$和输出变量向量$\vec{o}$。

如图\ref{c2_fsm}b)所示，
有限状态机$M$的行为可以通过将迁移函数展开多步得到。
在第n步上，
状态变量$s\in\vec{s}$，输入变量$i\in\vec{i}$ 和输出变量$o\in\vec{o}$
分别表示为$s_n$，$i_n$ 和 $o_n$。
进一步的，
在第n步的状态变量向量，输入变量向量和输出变量向量分别记为$\vec{s}_n$，$\vec{i}_n$ 和 $\vec{o}_n$。
一条路径是一个状态序列$<\vec{s}_n,\dots,\vec{s}_m>$ 使得$\exists \vec{i}_j\vec{o}_j (\vec{s}_{j+1},\vec{o}_j)\equiv T(\vec{s}_j,\vec{i}_j)$ 对所有$n\le j< m$均满足。
一个环是一条路径$<\vec{s}_n,\dots,\vec{s}_m>$使得$\vec{s}_n\equiv \vec{s}_m$。

\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{c2_fsm}
  \caption{有限状态机及其迁移关系的展开}
  \label{c2_fsm}
\end{figure}


\section{对偶综合研究现状}\label{sec_now}
本节将简述对偶综合领域取得的研究成果。
由于其中的若干算法也将在本论文的主要章节中被使用，
因此其描述方式根据本论文的需要进行了修改。
因此有可能和原始论文的描述方式有轻微出入。
在阅读本论文是应以本小节的描述为准。

\subsection{早期的充分非完备算法}

国防科技大学的Shen et al.\upcite{ShenICCAD09}首次提出了对偶综合的概念和初步算法实现。
该算法是充分非完备的，
这意味着当特定编码器对应的解码器存在时，
该算法总能找到其实现；
而当解码器不存在时，
该算法不停机。

对于每一个$i\in\vec{i}$，
在展开的迁移函数序列上，
如果存在三个参数$p$， $l$ 和$r$，
使得对于输出序列$<\vec{o}_p,\dots,\vec{o}_{p+l+r}>$的任意取值，
$i_{p+l}$不能同时取值为0和1，
则输入变量$i\in\vec{i}$可以被唯一决定。
这等价于等式(\ref{uniqt1})中的公式$F_{PC}(p,l,r)$的不可满足。

\begin{equation}\label{uniqt1}
% \begin{split}
F_{PC}(p,l,r):=
\left\{
\begin{array}{cc}
&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s}_{m+1},\vec{o}_m)\equiv T(\vec{s}_m,\vec{i}_m)
\}
\\
\wedge&\bigwedge_{m=0}^{p+l+r}
\{
(\vec{s'}_{m+1},\vec{o'}_m)\equiv T(\vec{s'}_m,\vec{i'}_m)
\}
\\
\wedge&\bigwedge_{m=p}^{p+l+r}\vec{o}_m\equiv \vec{o'}_m \\
\wedge& i_{p+l}\equiv 1 \wedge  i'_{p+l}\equiv 0 \\
\wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i}_m) \\
\wedge&\bigwedge_{m=0}^{p+l+r}assertion(\vec{i'}_m)
\end{array}
\right\}
% \end{split}
\end{equation}

\begin{figure}[t]
\begin{center}
\includegraphics[width=\textwidth]{pc}
\end{center}
\caption{用于检查$i_{p+l}$ 是否能够被唯一决定的下估计算法}
  \label{fig_pc_double}
\end{figure}


这里，
$p$是前置迁移函数序列的长度，
$l$ 和$r$则是两个用于唯一决定$i_{p+l}$的输出序列
$<\vec{o}_{p+1},\dots,\vec{o}_{p+l}>$ 和$<\vec{o}_{p+l+1},\dots,\vec{o}_{p+l+r}>$
的长度。
等式(\ref{uniqt1}) 的行1对应于图\ref{fig_pc_double}左边的路径，
而行2对应于图\ref{fig_pc_double}右边的路径。
他们的长度是相同的。
行3强制这两条路径的输出是相同的。
而行4要求他们的输入$i_{p+l}$ 是不同的。
行5和6则是用户给出的断言，
用于约束合法的输入模式。
$F_{PC}$ 中的PC是"parameterized complementary"的缩写，
意味着$F_{PC}(p,l,r)$ 被用于检查在三个参数 $p$,$l$ 和 $r$的情况下，
$i_{p+l}$能否被唯一决定。


从图\ref{fig_pc_double}可知，
等式(\ref{uniqt1}) 的前三行代表了两个具有相同输出的迁移函数展开序列。
因此他们总是可满足的。
而最后两行是对合法输入模式的约束。
我们将在算法开始前检查他们的可满足性。
所以$F_{PC}(p,l,r)$ 的不可满足意味着$i_{p+l}\equiv i'_{p+l}$，
即输入被唯一决定。

从图\ref{fig_pc_double}可知，
如果$F_{PC}(p,l,r)$ 不可满足
则$F_{PC}(p',l',r')$ 对于更大的$p'\ge p$， $l'\ge l$ 和$r'\ge r$也不可满足。
从等式(\ref{uniqt1})中可知，
$F_{PC}(p',l',r')$ 的短句集合是$F_{PC}(p,l,r)$的超集。
这也指向了同一个结论。

这意味着，
$F_{PC}(p,l,r)$的不可满足性的限界证明可以被扩展到
任意$p$， $l$ 和$r$上，
从而成为非限界的证明。

\begin{proposition}\label{prop_pc1}
如果$F_{PC}(p,l,r)$ 不可满足，
则对于任意更大的$p$， $l$ 和$r$，
$i_{p+l}$ 能够被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$ 唯一决定。
\end{proposition}


上述命题仅考虑了输入向量$\vec{i}$中的一个输入变量$i$。
当需要讨论整个$\vec{i}$时，
我们需要将整体的$p$， $l$ 和$r$设置为最大值。
即，
假设对于$i\in\vec{i}$，
其对应的唯一决定参数为$p_i$， $l_i$ 和$r_i$，
则对于整个$\vec{i}$，
其对应的唯一决定参数为：
\begin{equation}\label{equ_maxplr}
\begin{array}{ccc}
p & :=  & max_{i\in\vec{i}} \{p_i\}\\
l & :=  & max_{i\in\vec{i}} \{l_i\}\\
r & :=  & max_{i\in\vec{i}} \{r_i\}
\end{array}
\end{equation}

等式(\ref{uniqt1}) 不包含初始状态，
相反使用一个长度为$p$步的前置状态序列$<\vec{s_0},\dots,\vec{s_{p-1}}>$
以将约束$assertion(\vec{i})$传播到状态序列$<\vec{s_p},\dots,\vec{s_{p+l+r}}>$。
从而将在$assertion(\vec{i})$ 约束下不可达的状态集合剔除。
相比考虑初始状态的传统方法，这带来了两个主要的好处：
首先，
通过不计算可达状态，
本文算法可以得到极大的简化和加速。
而相比之下，目前唯一能够计算可达状态的对偶综合算法\upcite{TuDAC13}
则无法处理最为复杂的XFI编码器。
而我们的算法\upcite{ShenTCAD11}则始终可以处理。
第二，
通过忽略初始状态，本文算法可以提升产生出来的解码器的可靠性。
因为这可以使得解码器的状态和输出仅仅依赖于有限的输入历史。
因此任何被传输中的错误破坏的$\vec{o}$ 只能对解码器产生有限步数的影响。

当然忽略初始状态有一个缺点在于，
他使得判断条件比必须的情况稍微强一些。
也就是说，
他要求$\vec{i}$ 必须在一个更大的集合$R^p$上被唯一决定。
其中$R^p$代表了由任意状态在$p$步之内能够到达的状态集合。
而必要条件是从初始条件出发在任意步数内可以到达的可达状态集合$R$。
因此在某些情况下，
我们的算法有可能无法处理正确设计的编码器。
不过从目前使用的所有编码器，即使是那些来自于真实工业应用的编码器，
这种极端情况也没有出现过。


\subsection{完备停机算法}


在上一小节，
我讨论了当$F_{PC}(p,l,r)$ 不可满足时，
$i_{p+l}$能够针对任意$p$， $l$ 和$r$被唯一决定。
另一方面，
如果$F_{PC}(p,l,r)$ 是可满足的，
则$i_{p+l}$ 不能在特定的$p$， $l$ 和$r$情况下被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$唯一决定。
此时存在两种可能性：
\begin{enumerate}
 \item
在更大的$p$， $l$ 和$r$情况下$i_{p+l}$能够被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$ 唯一决定。
 \item
对任意$p$， $l$ 和$r$，$i_{p+l}$ 都不能够被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$ 唯一决定。
\end{enumerate}

如果是第一种情况，
则通过迭代的增长$p$， $l$ 和$r$，
$F_{PC}(p,l,r)$ 总能够变成不可满足。
然而对于第二种情况，
迭代的递增$p$， $l$ 和$r$将导致不停机。

\begin{figure}[t]
\begin{center}
\includegraphics[width=\textwidth]{ln}
\end{center}
\caption{用于检查$i_{p+l}$ 是否不能被唯一决定的上估计算法}
  \label{fig_ln_double}
\end{figure}

因此，
为了得到一个停机算法，
我们需要区分上述两种情形的手段。
国防科技大学的Shen et al.\upcite{ShenTCAD11}和Liu et al.\upcite{LiuICCAD11}分别独立提出了类似的全新的解决方案。
该方案如图\ref{fig_ln_double}所示，
该图类似于图\ref{fig_pc_double}，
但是增加了三个约束用于检测三个路径$<\vec{s}_{0},\dots,\vec{s}_{p}>$，$<\vec{s}_{p+1},\dots,\vec{s}_{p+l}>$ 和
$<\vec{s}_{p+l+1},\dots,\vec{s}_{p+l+r}>$上的环。
该方法被形式化的定义于等式(\ref{uniqln}) 中。

\begin{equation}\label{uniqln}
% \begin{split}
F_{LN}(p,l,r):=\\
\left\{
\begin{array}{cc}
&F_{PC}(p,l,r)\\
\wedge&\bigvee_{x=0}^{p-1}\bigvee_{y=x+1}^{p} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+1}^{p+l-1}\bigvee_{y=x+1}^{p+l} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\} \\
\wedge&\bigvee_{x=p+l+1}^{p+l+r-1}\bigvee_{y=x+1}^{p+l+r} \{\vec{s}_x\equiv \vec{s}_y\wedge \vec{s'}_x\equiv \vec{s'}_y\}
\end{array}
\right\}
% \end{split}
\end{equation}

$F_{LN}$ 中的LN意味着环形非对偶。
这表明$F_{LN}(p,l,r)$ 将使用这三个环检测约束来检测$i_{p+l}$是否不能够被唯一决定。

当$F_{LN}(p,l,r)$ 可满足，
则$i_{p+l}$ 不能被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$唯一决定。
更重要的，
通过展开这三个环，
我们能将这个结论扩展到任意更大的$p$， $l$ 和$r$上。
这意味着：

\begin{proposition}\label{prop_ln1}
当$F_{LN}(p,l,r)$ 可满足时，
$i_{p+l}$ 针对任意$p$， $l$ 和$r$都不能被$<\vec{o}_{p},\dots,\vec{o}_{p+l+r}>$ 唯一决定。
\end{proposition}



\begin{algorithm}[t]
\caption{$CheckUniqueness(i)$:用于检测$i\in\vec{i}$是否能够被$\vec{o}$的有限长度序列唯一决定的停机算法}
\label{alg_pcln_chap1}
\begin{algorithmic}[1]
\STATE $p$:= 0;
\STATE $l$:= 0;
\STATE $r$:= 0;
\WHILE {$1$}
\STATE $p$++;
\STATE $l$++;
\STATE $r$++ ;
\IF{$F_{PC}(p,l,r)$ 不可满足}\label{linepc1}
\RETURN ($1$,$p$,$l$,$r$)\label{lineln1};
\ELSIF{$F_{LN}(p,l,r)$ 可满足}\label{lnsat}
\RETURN ($0$,$p$,$l$,$r$);
\ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

%
%\KwIn{The input variable $i\in\vec{i}$.}
%\KwOut{whether $i\in\vec{i}$ can be uniquely determined by $\vec{o}$, and the value of $p$, $l$ and $r$.}




根据命题\ref{prop_pc1} 和\ref{prop_ln1}，
我们能将针对特定$p$， $l$ 和$r$的限界证明扩展到针对任意$p$， $l$ 和$r$的非限界情形。
这使得我们得到停机算法\ref{alg_pcln_chap1}，
用于检测$i\in\vec{i}$是否能被$\vec{o}$的有限长度序列唯一决定。
\begin{enumerate}
 \item
一方面，
如果确实存在$p$， $l$ 和$r$，使得输入能被输出唯一决定，
令$p':=max(p,l,r)$,$l':=max(p,l,r)$ 和$r':=max(p,l,r)$。
从命题\ref{prop_pc1}，
可知$F_{PC}(p',l',r')$ 是不可满足的。
因此$F_{PC}(p,l,r)$ 总能够在算法\ref{alg_pcln_chap1}行\ref{linepc1}成为不可满足的并退出循环；
 \item
另一方面，
如果不存在这样的$p$， $l$ 和$r$，
则$p$， $l$ 和$r$ 在不断的递增之后最终总能够大于有限状态机的最大无环路径长度。
这意味着在$<\vec{s}_{0},\dots,\vec{s}_{p}>$，$<\vec{s}_{p+1},\dots,\vec{s}_{p+l}>$ 和
$<\vec{s}_{p+l+1},\dots,\vec{s}_{p+l+r}>$上都存在环。
这将使得$F_{LN}(p,l,r)$ 在行\ref{lnsat}被满足。这样将导致退出循环。
\end{enumerate}


因此该算法是停机的。



\subsection{在对偶综合领域的其他的相关工作}

Shen et al.\upcite{ShenTCAD12}和Liu et al.\upcite{LiuICCAD11} 独立的发现可以通过Craig 插值加速解码器的生成。
该算法还将作为下一章的一部分单独介绍，
因此不在这里展开描述。

Shen et al.\upcite{ShenTCAD12} 自动的发掘能够使得解码器存在的前提条件，
首次发现在同一个前提条件下，
存在多个不同的解码器。
为了方便用户区分和选择，
该文还提出了单独的算法来寻找所有这些解码器，
并推导他们存在的前提条件。

Tu et al.\upcite{TuDAC13}提出了一个突破性的算法，
通过使用属性指导的可达性分析算法\upcite{BradleyVMCAI11,EenFMCAD11}，
将初始条件考虑到解码器存在性检测中。
该算法是第一个能够考虑初始条件的对偶综合算法。




\section{基于白盒模型的对偶综合}\label{sec_whiteboxtodo}
本节阐述基于白盒模型的对偶综合技术的重要研究意义，并讨论从事该研究所面临的主要挑战。



\subsection{研究意义}

现代复杂通讯协议的编码器中，广泛采用了流水线和流控机制\upcite{flowcontrol}技术。
以提高性能并增强对环境的适应能力。
而目前在对偶综合方面的所有研究工作\upcite{ShenICCAD09,ShenTCAD10,ShenTCAD11,ShenICCAD11,ShenTCAD12,LiuICCAD11,LiuTCAD12,TuDAC13}
均基于黑盒模型，
完全忽视上述的内部结构，
从而无法发挥上述内部结构在性能和适应性方面的优势。


\subsection{研究意义}




\section{研究内容与创新点}\label{sec_contest_innov}
为了克服上述问题，
本文基于白盒模型，
探索了如何在对偶综合中发掘编码器的内部结构信息，
如流控和流水线结构，
以自动产生支持相应结构的解码器。
本文的主要研究内容及创新点包括以下几方面：

本文受国家自然科学基金项目“面向通讯应用的自动对偶综合方法研究”（项目编号61070132）的支持，主要贡献和创新点如下：



第一，研究了基于余因子(Cofactoring)和Craig插值\upcite{Craig}的迭代特征化算法。
在发掘编码器内部结构和自动产生解码器的过程中，
一个必须而且对性能要求非常苛刻的步骤，
是特征化满足特定命题逻辑关系$R$的布尔函数$f$。
传统的算法包括基于SAT或BDD的完全解遍历和和量词削减。
然而这些算法通常受到解空间不规则的困扰，
导致性能低下。
为此，
我们创造性的提出了一个迭代的特征化算法框架。
在每一次迭代中，
为每一个尚未被遍历的解$A$，
利用其对应的余因子化简$R$以满足产生Craig插值要求。
而该插值是$A$的一个充分扩展。
该迭代过程是停机的，
且其性能比传统的完全解遍历算法有巨大的提升。

第二，研究了针对流控机制的对偶综合算法。
传统对偶综合算法的\upcite{ShenICCAD09,ShenTCAD10,ShenTCAD11,ShenICCAD11,ShenTCAD12,LiuICCAD11,LiuTCAD12,TuDAC13} 的一个基本假设是，
编码器的输入变量$\vec{i}$总能够被输出变量$\vec{o}$的一个有限长度序列唯一决定。
基于该假设方可构造满足Craig插值的不可满足公式。
然而，
许多高速通讯系统的编码器所带有流控机制\upcite{flowcontrol}，
直接违反了上述假设。
该机制将$\vec{i}$划分为有待编码的数据向量$\vec{d}$和用以表达$\vec{d}$有效性的流控向量$\vec{f}$，
并在$\vec{f}$上定义一个有效性谓词$valid(\vec{f})$。
只有在$valid(\vec{f})\equiv 1$的情形下，
$\vec{d}$才能够被$\vec{o}$唯一决定。
为此，
我们创造性的提出了能够处理流控机制的对偶综合算法：
\textbf{首先}，
它使用经典的对偶综合算法\upcite{ShenTCAD11}
以识别那些能够被唯一决定的输入变量，
并称他们为流控变量$\vec{f}$。
而其他不能被唯一决定的变量称为数据变量$\vec{d}$。
\textbf{第二}，该算法推导一个充分必要谓词$valid(\vec{f})$使得$\vec{d}$能够被
输出变量$\vec{o}$的一个有限长度序列唯一决定。
\textbf{第三}，
对于每一个流控变量$f\in\vec{f}$，
该算法使用Craig插值算法\upcite{interp_McMillan}特征化其解码器函数。
同时，
对于数据变量$\vec{d}$，
他们的值只有在$valid(\vec{f}) \equiv 1$时才有意义。
因此每个$d\in\vec{d}$的解码器函数可以类似的使用Craig插值算法得到，
唯一的不同在于必须首先应用谓词$valid(\vec{f}) \equiv 1$。



第三，研究了针对流水线结构的对偶综合算法。
现代集成电路中的编码器，
为了提升工作频率，
通常包含多个流水线级，
以将关键的数据路径划分为多级。
而传统的对偶综合算法\upcite{ShenICCAD09,ShenTCAD10,ShenTCAD11,ShenICCAD11,ShenTCAD12,LiuICCAD11,LiuTCAD12,TuDAC13}
完全无视这种流水线结构，
从而导致生成的解码器无法保持和编码器匹配的频率和性能。
为此，
我们创造性的提出了能够产生流水解码器的对偶综合算法：
首先将传统对偶综合算法推广到非输入输出情形，
以找到编码器中每一个流水线级$\vec{stg}^j$中的寄存器集合；
然后使用迭代Craig插值算法特征化每一个流水线级$\vec{stg}^j$的布尔函数，
以从下一个流水线级$\vec{stg}^{j+1}$ 或输出$\vec{o}$之中恢复$\vec{stg}^j$。
最终特征化$\vec{i}$的布尔函数以从
第一个流水线级$\vec{stg}^0$中恢复$\vec{i}$。

第四，结合上述研究成果，研究了能够同时处理流控和流水线结构的对偶综合算法。
该算法首先使用秦et al. \cite{QinTODAES15}的算法来寻找$\vec{f}$ 并推导$valid(\vec{f})$。
然后分别通过强制和不强制$valid(\vec{f})$，
已从所有寄存器集合中找到每一个寄存器级$\vec{stg}^j$的$\vec{d}^j$ 和$\vec{f}^j$。
最后通过Jiang et al. \cite{InterpBoolFunction}的算法特征化$\vec{stg}^j$ 和$\vec{i}$的布尔函数。

综上所述，
本文对基于白盒模型的对偶综合算法中若干关键问题进行了深入的研究，
提出了针对流控和流水线结构的解决方案。
理论分析和实验结果验证了所提出算法的有效性和性能，
对于进一步促进对偶综合算法的发展和应用具有一定的理论意义和应用价值。

\section{论文组织结构}
论文共分七章，组织结构如下：

第一章为绪论，介绍了相关的背景知识，对偶综合的基本概念、特点、应用以及研究现状。分析基于白盒模型的对偶综合技术的研究意义，并简述本文的研究内容和组织结构。

第二章描述了基于余因子和Craig插值\upcite{Craig}的迭代特征化算法。该算法在推导控制流谓词和特征化解码器的布尔函数中被广泛使用。

第三章描述了面向流控机制的对偶综合算法。

第四章描述了面向流水线结构的对偶综合算法。

第五章将上述两个算法有机的结合在一起，能够处理同时包含流控和流水线结构的编码器。

第六章总结全文并展望未来的工作。

最后是致谢、博士期间撰写的论文、参加的科研工作以及参考文献。
