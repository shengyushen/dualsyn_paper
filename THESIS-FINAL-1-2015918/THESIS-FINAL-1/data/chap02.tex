% !Mode:: "Tex:UTF-8"
\chapter{相关研究}
随着网格和云计算等开放计算环境从概念走向实用，针对科学计算在开放环境下安全外包的相关研究也逐渐兴起。科学计算的安全外包主要关注两方面的问题：
一是计算数据的隐私性，二是计算结果的正确性。

计算的隐私保护、可验证计算和混淆是其中三个重要支撑技术。
面向计算的隐私保护和可验证计算，聚焦于开放计算环境中输入输出数据的隐私和计算结果完整性保护；
而混淆着眼于对部署于开放环境下的计算程序和电路自身的隐私保护。

\label{chap:2}
\section{外包计算的隐私保护研究}
由于计算数据的隐私性涉及到商业秘密，成为了影响用户是否采用开放计算环境的决定性因素。
近几年，随着云计算和网格计算在商业模式上的逐渐推广和普及，
外包计算的隐私保护问题更加引起了学术界和工业界的关注。

按照采用的方法不同，计算数据的隐私保护可以分为基于同态加密(homomorphic encryption)的方法和基于数据伪装(disguising) 的方法。
伪装和加密的区别在于，伪装并不改变被外包的算法，而只是改变被外包的数据。
而被外包的数据在经过伪装之后，仍然能够保持问题本身所需的某些特性，以便获得最终解。
伪装方法依赖于特定问题和特定伪装算法的选择，对数据的保护程度缺乏一个统一的框架，但是对被外包算法性能影响小。
数据转换和数据分割是两种最为常用的伪装方法，数据转换方法是通过一个可逆的运算将数据转换为外包数据，并使用逆运算从外包计算结果中恢复真实结果；而数据分割方法则通过将数据分散到不同的计算单元，使得第三方无法了解被外包问题的全部。

而同态加密方法则将被外包的数据和算法都映射到加密空间，并保证这种映射是同态的；该方法能够提供一个统一的框架来保证数据的安全性。
但是同态性要求使得其实现开销非常高。
下面将分别介绍这几种方法的相关研究。

\subsection{基于同态加密的方法}
同态加密技术对密文进行某些特定代数运算，而且保证对明文的运算结果进行加密得到的结果与该运算结果相同。同态加密技术一般包括密钥生成(keygen)、加密(encrypt)、求值(evaluate) 和解密(decrypt)四个步骤：

\begin{enumerate}
\item 密钥生成算法：该算法输入安全参数，输出用户的公钥和私钥。
\item 加密算法：该算法输入用户的公钥和明文数据，输出相应的密文。
\item 求值算法：该算法输入用户的公钥、一个函数和一组密文，输出一个新密文。
\item 解密算法：该算法输入用户的私钥和密文，输出对应的明文数据。
\end{enumerate}

根据可支持代数运算种类的不同，同态加密技术又可以分为部分同态加密和完全同态加密两种。
其中，
部分同态加密只能对密文进行某些运算，
而完全同态加密方案则能够对密文进行任意运算。

部分同态加密系统在非加密空间$D$和加密空间$D'$之间，
针对加法或者乘法函数$f$，相应地构造加密空间上的运算函数$f'$，
以及对应的加密映射$E$和解密映射${E^{-1}}$，
使得$y=E^{-1}(f'(E(x))$。
此时称$E$是$f$的一个部分同态加密映射。
常见的部分同态加密系统包括Unpadded RSA\upcite{DBLP:journals/cacm/RivestSA78}，
ElGamal\upcite{DBLP:conf/crypto/Gamal84}， Goldwasser-Micali\upcite{DBLP:conf/stoc/GoldwasserM82}和
Paillier\upcite{DBLP:conf/eurocrypt/Paillier99} 等。

在实际应用需要对密文进行较为复杂的操作时，以上部分同态加密方案就无法满足这种需求。
针对这一问题，Gentry\upcite{DBLP:conf/stoc/Gentry09} 提出了非常优雅的理论框架，以构造针对乘法和加法同时保持的全同态加密算法。
该方法的基本思想在于使用一连串的基于噪声的近似同态加密。
近似同态意味着，每一次加密仅能够在一定步数$S$ 内，而不是任意步数内，对加法和乘法运算同时保持同态特性。当在加密空间$D_i$ 中的运算步数达到$S$时，为了防止累积的噪声导致解码失败，该方法将中间计算结果$r_i$，以及解密该结果的函数$d_i$，一起映射到新的加密空间$D_{i+1}$，并在其中运行解密函数$d_i$以得到中间结果$r_i$。 
此时由于$r_i$ 处于$D_{i+1}$ 中，所以运行该运算的云代理将在不知道$r_i$的情况下，完成后续$S$步的运算，以得到新的中间结果$r_{i+1}$。 如此迭代，即可最终得到能够对加法和乘法同时同态的加密系统。

Gentry等人在\upcite{Implementing-fully-homomorphic}中给出了上述理论框架一个完整的参考实现，
但运行结果显示该方案需要较大的时间和空间开销。
Scholl等人\upcite{Improved-key-generation}和Stehle等人\upcite{DBLP:conf/asiacrypt/StehleS10}分别改进实现方案，
得到运行效率更高的完全同态加密方案。
在上述方案的基础上，Smart等人\upcite{DBLP:conf/pkc/SmartV10}根据剩余定理，
设计了密钥和消息长度都较小的新方案。
Gentry在文献\upcite{DBLP:conf/crypto/Gentry10}中设计了新的密钥生成算法，
将完全同态加密方案的安全性，
建立在稀疏子集求和问题和理想格中最坏情况下的困难(hardness)问题之上。

为了有效地对不同用户的加密数据进行计算，
Lopez-Alt等人\upcite{DBLP:conf/stoc/Lopez-AltTV12}基于理想格，设计了一种允许多个密钥参与的完全同态加密方案。
该方案比传统的完全同态加密方案更加灵活和实用，但其安全性依赖于一个非标准的假设。
Bos等人\upcite{DBLP:conf/ima/BosLLN13}采用Brakerski等人\upcite{DBLP:conf/crypto/Brakerski12} 提出的技术，
消除了该假设。

上面的方案均是基于理想格或类似方法来构造的，存在不易理解的问题。
因此Van等人\upcite{DBLP:conf/eurocrypt/DijkGHV10} 设计了基于整数环的完全同态加密方案。
Coron 等人\upcite{DBLP:conf/crypto/CoronMNT11,DBLP:conf/eurocrypt/CoronNT12}和
Chen等人\upcite{DBLP:conf/eurocrypt/ChenN12}针对Van方案中的问题，提出多种的改进方案。
Gu等人\upcite{DBLP:conf/eurocrypt/CheonCKLLTY13,DBLP:journals/corr/abs-1202-3321,DBLP:journals/isci/CheonKLY15} 也进行相关的研究。

LWE(Learning with errors)\upcite{DBLP:conf/coco/Regev10}通过引入数量较小的错误作为噪音值，
增加高斯消去法的求解难度。
其难度为基于理想格的最坏情况。
而基于环的R-LWE(Ring-Learning with errors)是一种构造复杂性适中，安全性和LWE相当的新算法。
打包技术(packed)是通过SIMD 方式对明文向量而不是对单个明文进行加密，以提高同态加密效率的一种方法。
鉴于性能是完全同态实现方案中存在的最大问题，
Gentry等人在文献\upcite{DBLP:conf/eurocrypt/GentryHS12} 中采用将明文打包的方法，基于R-LWE\upcite{DBLP:conf/eurocrypt/LyubashevskyPR10}设计了一个时间开销仅为多项式对数的完全同态加密方案。随后在文献\upcite{DBLP:conf/pkc/GentryHS12}中又通过将模设置为2的幂的近似值，得到了一个效率更高的方案。
Brakerski等人\upcite{DBLP:conf/pkc/BrakerskiGH13,DBLP:journals/siamcomp/BrakerskiV14,
DBLP:conf/crypto/BrakerskiV11}
利用Peikert等人\upcite{DBLP:conf/crypto/PeikertVW08}的打包技术，设计了一种基于标准LWE问题和R-LWE问题的简单且安全性较高的完全同态加密方案，
并在安全性和效率上进行了一系列改进的工作\upcite{DBLP:journals/toct/BrakerskiGV14}。

针对SAT问题的隐私保护，Brakerski\upcite{OBfuscationd-CNFs} 等人探讨了使用多线性映射方法和坡度编码策略对d-CNF 进行混淆。
该方法使用随机和带有噪声的编码，并提供测试过程来确保编码元素的等价。
这种方法基于有限加速假设，并使用最原始的二叉树搜索方法求解混淆后的CNF。
由于无法利用目前经典的SAT 求解器，因此计算开销仍然是制约其实用化的重要因素。

\subsection{基于数据伪装的方法}
按照对数据域的转换方式，数据伪装可分为数据域扩展和数据域分片两种。

数据域扩展使原始数据无缝地包含于伪装后数据中。
典型的如基于可逆矩阵乘法的伪装。
其原理是，将原始矩阵数据与可逆矩阵相乘。
由于n阶矩阵都有$n!$个置换矩阵，因此还原出原始矩阵的可能性为$1/n!$。
M. J. Atallah\upcite{DBLP:journals/ac/AtallahPRS01} 针对科学计算中常见的多种线性代数算法，将有待外包的数据与随机对角矩阵，进行矩阵乘。结果可以通过可逆的矩阵运算得到。该论文还讨论了问题域的扩展和缩减，以进一步伪装计算的真正企图。该方法的一个问题是没有讨论如何验证返回的结果的正确性。
C. Wang\upcite{c.WANG}继承了上述工作中对等式的伪装方法，并创造性的针对线性规划问题中的不等式和优化目标找到了安全而有效的伪装算法。
同时该论文还讨论了如何验证返回结果的正确性。
他们的方法是基于问题转换的，不需要引入额外的开销。
但是，这些技术需要花费与计算负载成立方关系的时间，不适用于弱客户端系统，无法处理大规模问题。
C. Wang等人\upcite{DBLP:journals/tpds/WangRWW13}在大规模线性方程组的外包求解问题中，
利用矩阵-向量乘的代数属性，对结果以批处理方式进行验证。
针对SAT问题的特点，Qin在文献\upcite{DBLP:conf/apweb/QinSKD14,qyMemocode14} 提出了基于CNF混淆的SAT计算隐私保护算法。
文献\upcite{DBLP:conf/apweb/QinSKD14} 讨论了SAT计算中输入数据的隐私保护算法。通过在输入数据中按照特定的规则混入噪音数据，在保持解空间不变的前提下，隐藏真实输入数据信息。
文献\upcite{qyMemocode14}进一步讨论了输出的隐私保护。通过对混淆后解空间的上估计扩展实现输出数据的隐藏，并从理论上证明了混淆算法的正确性。

对数据域进行分片计算，使得计算者无法获得全局数据也是一种有效的数据伪装方法。
M. J. Atallah\upcite{DBLP:journals/ac/AtallahPRS01,DBLP:journals/ijisec/AtallahL05} 部分的借鉴了加密算法的思想。
同时分别针对序列运算和代数计算的特点，将被外包的问题划分为两个子集，并外包到多个不存在合作关系的代理中，保证每个代理都无法了解被外包问题的全部。
在\upcite{DBLP:conf/ccs/AtallahF10} 中，M. J. Atallah放弃了非合作代理假设，允许多个敌意代理之间通过使用机密共享机制
\upcite{DBLP:journals/cacm/Shamir79} 交换信息，进行协同求解。
而每一个代理都不能获得待求解问题的整体信息。然而该机制也导致了通讯开销的急剧增长。
另外，这些协议都是在假定非共谋(non-colluding)服务器的情况下作出，无法防御共谋(colluding)攻击。
Yuriy Brun\upcite{DBLP:conf/IEEEcloud/BrunM12} 等人则使用了stile数据分布的模式，通过将数据条块计算，提高攻击者获得完整计算数据的难度，以此降低数据被窃取的可能性。
该研究主要针对SAT问题的求解，通过将CNF子公式分布在多个计算节点上，防止CNF公式泄露。该方法目前也仅仅支持简单的二叉遍历赋值求解方法，无法利用已有的SAT 求解加速算法，因此计算开销仍然是进行大规模的SAT问题求解的主要障碍。


\section{计算完整性验证研究}
如果说计算数据的隐私性是外包之前需要关注的重要问题，外包计算结果的正确性则是计算外包结束之后必须确认的事情。
由于网格计算和云计算环境下，计算外包至云端来执行，主要计算过程均在客户无法掌控的环境中进行。
网格计算节点和云端服务器恶意或无心的错误都会对用户的计算结果造成影响。

Du等人\upcite{HV-grid}指出在早期出现的开放计算环境——志愿计算模式下，部分参与计算的志愿者会给出错误结果。
大规模的统计表明，给出错误结果的志愿计算者可分为三类：懒惰欺骗者，私心欺骗者和恶意欺骗者。
其中懒惰欺骗者希望少干活多获得报酬，为节约计算成本，不会进行全部计算，因而仅能给出部分结果甚至不会返回结果；
私心欺骗者会进行全部计算，但会希望私留部分结果，对用户进行瞒报或仅仅将部分正确结果返回给用户；
恶意欺骗者则不进行计算或者进行错误计算，而将错误结果返回给用户。

开放计算环境下这些威胁，催生了可验证计算的研究。
可验证计算的目标是确保一个弱计算能力的客户，都可以验证不可信服务器上计算的完整性。
其中计算完整性不仅包括计算结果的在数值上是准确的，还包括计算结果在数量上是完整的。

多副本技术是容错的传统技术，主要利用冗余计算的思想。
该技术通过将同一个任务部署在多个计算节点同时进行，并对计算结果进行评估，超过半数的相同结果将被采纳。
由于该类方法简单易行，在实际应用中最为广泛。
但是多副本计算存在开销大的问题，并且无法防止节点共谋的情况。

为此，研究者提出了基于抽样验证的技术。
抽样验证技术是指用户指定抽测样本，由计算者进行计算，而后用户检测样本的计算结果是否正确，
以此来判断此节点所有结果的正确性。
Du等人\upcite{DBLP:conf/icdcs/DuJMM04}提出了基于提交的抽样，在计算者提交结果之后进行抽
样复算。
由于此时计算者已经不能改变计算结果，这就迫使计算者要提供完整的正确结果。

Golle等人\upcite{DBLP:conf/ctrsa/GolleM01}利用单向函数的特点，
在参与者所处理的数据域中随机选取部分数值并计算其单向函数值，要求参与者给出这些函数值对应的数值。
由于单向函数的难解性，参与者无法由函数值直接推出数值，因此必须遍历数据域，完成所有的计算作业。
通过上述方法防止恶意以及懒惰工人的欺骗行为。
Szajda等人\upcite{DBLP:conf/sp/SzajdaLO03}扩展了上述策略，针对任务优化的计算外包以及MonteCarlo方法的计算外包，
通过检测返回结果中探针结果的正确性，来检测是否存在恶意欺骗和懒惰欺骗的情况。
M Blanton\upcite{DBLP:conf/socialcom/BlantonZF11} 在生物实验数据中随机插入用于结果校验的特定数据模式，
并在计算完成后检查结果是否包含由这些模式导致的特定要求。

Du等人\upcite{HV-grid}为了防止私心欺骗者，
在待计算的实例中混入一定比例的chaff实例。
由于chaff与计算实例在形式上难以区分，
使得计算节点无法确定计算结果是真实结果还是chaff结果。
由于chaff实例结果预先已知，因而迫使计算节点返回所有的计算结果。
Du针对子图同构检测和SAT问题分别给出了chaff实例的构造方法。

云计算作为一种近期出现的开放计算环境新模式，其在大规模数据上的出色表现，也对计算结果的完整性提出了更高的要求。
Wang等\upcite{DBLP:conf/IEEEcloud/2012}针对大规模数据处理架构Mapreduce的运算特点，
结合复算和验算技术，实现计算结果完整性检测。
结合云计算模式的细分和大数据处理的需求，
Wang等针对混合云下的大数据处理计算的结果完整性验证进行了一系列研究\upcite{6740233,DBLP:conf/bigdataconf/WangWSDD13}。
但是上述的研究未考虑到云计算中的数据隐私保护问题。

针对云计算大规模商业普及所带来的隐私保护和结果可信性的要求，R. Gennaro\upcite{R.Gennaro}提出安全可验证计算的概念，
给出了基于完全同态加密\upcite{C_Gentry_phd}和加密电路(Garbled-Circuit)\upcite{DBLP:conf/focs/Yao82b}
实现可验证的安全计算外包的方案。
方案不仅考虑对结果正确性的要求，数据的隐私性更是关注的重点。
但是这种方案只是给出了理论上的可行性，其构造的效率受限于完全同态加密方案的效率，
因此具体的应用实现还处于探索中。

上述的工作主要是用于结果验证的目的，但加入加密电路(garbled circuit)或是chaff实例等探针进行隐藏计算对本文的工作有一定的启发。

\section{混淆技术研究}
混淆\upcite{DBLP:journals/jacm/BarakGIRSVY12,obfuscationBible}
是一种可隐藏设计中的隐私，并使得设计更加难以理解的技术，在软硬件防盗版、防信息泄露等领域得到广泛的应用。
具体说来，混淆通过将程序或电路变形，并保证变形前后程序或电路的功能不变，达到隐藏或嵌入敏感信息的目的。
根据其应用领域，混淆又可细分为程序混淆、电路混淆。

\subsection{混淆理论研究}
混淆理论的研究始于2001年，Barak等人在\upcite{DBLP:conf/crypto/BarakGIRSVY01}中首次给出了混淆的概念。
其思想是将程序或电路变形，同时保证变形前后程序和电路的输入输出不变，
并使变形后的程序或电路看起来类似一个虚拟黑盒(virtual black box)，这一概念被称为黑盒混淆(Blackbox obfuscation)。
在他们确定的最初定义中，黑盒混淆需要满足下列特性：

\begin{enumerate}
\item 被混淆的电路和原始电路的功能相同，且至多有多项式的开销损耗。
\item 除了黑盒功能(输入输出），被混淆的电路不能泄露任何信息。
\end{enumerate}

从形式上看，Barak提出的黑盒混淆具有如下表现：混淆后电路可以进行有效计算，但仅可以通过电路的输入输出访问计算。
悲观的消息是，Babark等人的研究表明：不存在通用的黑盒混淆算法。

结合黑盒混淆的困境，
Barak等人\upcite{DBLP:conf/crypto/BarakGIRSVY01,DBLP:journals/jacm/BarakGIRSVY12}提出了不可区分混淆(indistinguishability obfuscation)的概念。
不可区分混淆给出了如下的要求：给定两个尺寸相同的等价电路$C_0$和$C_1$，他们的混淆结果计算时不可区分。
随后，Lynn\upcite{DBLP:conf/eurocrypt/LynnPS04} 等人给出了关于程序混淆的好消息：
点和多点类的函数可以通过随机oracle模型进行混淆。

混淆最常被应用于知识产权保护领域，如防止对软件程序进行反向工程，防止硬件IP/IC核非法使用和复制。
在IP核的保护中，由于混淆后网表会被交付出去，并且其功能也是公开的，将其看作是一个黑盒显然不合适。
基于上述实际的情况，Goldwasser等人\upcite{DBLP:conf/tcc/GoldwasserR07,DBLP:journals/joc/GoldwasserR14}提出基于放松要求的最佳可能混淆(Best Possiable Obfuscation)，并研究了其中的特性。
最佳可能混淆定义放松了Barak定义中要求的第二个特性，即放弃了黑盒假设，
而将其表述为不会比其他任何相同功能的电路泄露更多信息。
直观的看，最佳可能混淆保证任何不被混淆电路隐藏的信息，也无法被其他具有相同功能的电路隐藏；
这个放松条件并不绝对保证混淆电路可以隐藏信息，但保证该混淆电路是所有电路中在信息隐藏方面做得最好的。

随着云计算的发展，对外包计算的加密需求进一步激发了实用性混淆技术的研究。
在混淆理论研究的基础上，Sanjam等人\upcite{DBLP:conf/focs/GargGH0SW13}构造了一个不可区分混淆的参考实现，
该参考实现可以用于所有电路；他们还研究了该参考实现在函数加密上的应用。
Brakerski等人\upcite{DBLP:conf/crypto/BrakerskiR13}结合多线性映射和坡度编码，给出了DNF公式混淆的参考实现。
采用相同的编码方法和线性映射，
Brakerski等人\upcite{OBfuscationd-CNFs}还构造了d-CNF公式黑盒混淆的参考实现，并证明了其安全性。

混淆理论研究上的进展，已经由从对概念与特性的界定，发展到参考实现的设计。
但是，目前给出的参考实现均基于加密原语来构造，开销较大。
因此，理论研究上的成果还未在程序和电路保护中得到实际的广泛应用。

\subsection{程序混淆}
在实际应用中，程序混淆的主要目标是增加反向工程的难度，因此更多采用一些轻量级的混淆策略。
通过保持语义的程序转换使得代码难以理解，尽可能迫使攻击者因解混淆开销过大而放弃对代码的剽窃。
在程序混淆方面，最普遍的应用是保护Java字节码。
其目的是，通过混淆提高Java代码的理解难度\upcite{DBLP:conf/cc/BatchelderH07}。

程序混淆的典型方法\upcite{obfuscationBible}包括:
\begin{enumerate}
\item 词法混淆(Lexical obfuscation)：对程序中的标示符使用重命名技术，降低其可读性。
\item 数据混淆(Data obfuscation)：使用数据编码、变量数组的划分和融合(split and merge)，变量重排序以及继承关系修改等手段，改变程序中的数据结构。
\item 控制混淆(Control Obfuscation)：改变程序中的语句、循环和控制语句的顺序，使用无关的条件语句隐藏控制流的实际走向。
\item 妨碍混淆(Prevention obfuscation)：使用动态派发(dynamic dispatching)方法，防止解编译器(decompilers)编译出原始程序。针对Java代码，具体的方法有：将分支转换为跳转指令，不遵循构造器规范，将try语句和catch语句块融合，以及混淆字节码解释器。
\end{enumerate}

%词法混淆主要对程序中的标示符使用重命名技术，降低其可读性；
%数据混淆主要使用数据编码、变量数组的划分和融合(split and merge)变量重排序以及继承关系修改等手段，
%改变程序中的数据结构；
%控制混淆主要是改变程序中的语句、循环、控制语句的顺序，将使用无关的条件语句隐藏控制流的实际走向。

前三类混淆方法主要专注于降低程序的可阅读性，针对的是人类攻击者；
而第四类混淆方法主要用于预防自动解混淆(automatic deobfuscation)的攻击。

针对混淆的有效性，文献\upcite{Collberg_C}针对代码混淆的最初要求，
指出评价混淆有效性的四个维度：效能(potency)，适应力(resilience)，开销(cost)和隐形性(stealth)。
其中，效能衡量混淆引入的复杂性，复杂性越高，意味着程序越难以理解；
适应力衡量抵抗自动解混淆器攻击的能力；
开销衡量混淆程序的时空复杂性；
隐形性衡量了混淆前后程序的相似性。
该评价标准对我们的工作起到了指引的作用。

由于CNF公式是电路结构和软件程序的抽象，因此针对衡量程序混淆有效性的部分指标，也适用于衡量CNF 混淆。
特别指出的是，效能标准针对程序的可理解性，而CNF公式本身就具有难以理解的特点，因此我们采用后三个评价标准。

\subsection{电路混淆}
硬件计量(Hardware meter)\upcite{839821}和硬件水印(Hardware watermark)\upcite{DBLP:conf/dac/Oliveira99} 是防止硬件盗版的两类电路混淆技术。
和程序混淆主要用于隐藏程序自身信息的目标不同，
电路混淆主要目标是在硬件IC或IP中植入要隐藏的信息(例如水印)，防止非法使用或非法复制。

\subsubsection{硬件计量}
硬件计量亦称为集成电路计量，是由Koushanfar等人\upcite{DBLP:conf/ih/KoushanfarQP01}于2001年首次提出的概念。
其思想是通过将一小部分设计变为可编程状态，从而为集成电路的功能赋予一个唯一的标记。
其目的是使设计者(知识产权拥有者)对集成电路设计的后期投片仍然具有控制权。
硬件计量的研究工作主要集中于，利用制造可变性，为每个集成电路产生随机的身份标记，以便于获得计量。

按照是否对功能进行主动控制，硬件计量可分为主动方法和被动方法两类。
早期研究\upcite{839821,DBLP:conf/isscc/SuHO07,DBLP:conf/ih/KoushanfarQP01,DBLP:conf/dac/SuhD07}关注被动方法，
主要是研究如何为集成电路植入标记，而不涉及对电路功能的改变。
Alkabani等人\upcite{DBLP:journals/tifs/Koushanfar12,DBLP:conf/glvlsi/Koushanfar11} 给出了主动的硬件计量策略。
该策略利用了物理上不可克隆函数(PUF)为每一个集成电路产生唯一初始FF值(开机状态)。
开机状态有较高的可能性成为增强有限状态机的一部分，并导致集成电路处于锁住状态；
仅有增强有效状态机的设计者或被授权者，可以使用密钥(转化为合法的reset状态)来解锁集成电路。
Li等人\upcite{DBLP:conf/host/LiZ13}提出利用retiming、resynthesis、sweep和conditional stuttering
四类电路结构变换操作，来实现顺序电路的最佳可能混淆。
上述基于嵌入锁的方法，被称为内部主动集成电路计量。
相对于内部主动方法，
外部主动集成电路计量方法\upcite{DBLP:conf/date/RoyKM08,DBLP:conf/dac/RoyKM08,DBLP:conf/host/HuangL08}
将锁嵌入到设计的物理层，由外部的加密函数进行控制的。
由于加锁使用了复杂的加密模块，因此通常会导致较大的功耗开销和面积开销。


\subsubsection{硬件水印}
硬件水印技术\upcite{DBLP:conf/dac/Oliveira99}的研究最早始于1999年，
其目标是标注硬件所有权。
由于水印会导致某些非水印电路中不会出现的输入转换行为，硬件设计者可以此来证实所有权。
和硬件计量不同的是，水印的加入对集成电路的功能没有影响。
Oliveira等人\upcite{DBLP:journals/tcad/Oliveira01}
首先给出了在顺序电路中隐藏秘密水印的方法。
在该方法中，水印是通过修改状态迁移图(STG)实现的。
使用特定输入集合(密钥)来穿透状态转换选择路径，达到加入特定不可觉察信息的目的。
Koushanfar\upcite{DBLP:conf/host/KoushanfarA10}给出了加入多个水印来加强安全性的方法。
他们的工作同时表明，在状态迁移图中隐藏多个水印，是使用一般化输出来混淆多点函数的一个实例。
Yuan等人\upcite{DBLP:conf/ih/YuanQ04}给出了使用冗余的有限状态机来隐藏水印的方法。
他们还设计了一个基于SAT的算法，来发现给定最小化FSM中最大冗余转换集合，
并且利用这些冗余来隐藏FSM信息，并且不改变给定最小FSM。

硬件水印和被动硬件计量看上去相似，但有一些本质区别：
计量通常为每个集成电路赋予一个特殊的标记，同一个产品的所有集成电路中的水印是相同的。
因此，水印无法跟踪由同一模具产生出来的拷贝。

上述的技术对不受控制的软件产品和硬件设计进行主动保护或被动追踪，对于CNF公式的保护也有借鉴价值。

\section{本章小结}
本章综述了SAT问题及其隐私的基本概念和相关定义。
对与本文研究工作相关的计算外包隐私保护、可验证计算、以及程序电路混淆等问题进行了概述，并对这些问题中已有的研究工作进行了具体的介绍和分析。
